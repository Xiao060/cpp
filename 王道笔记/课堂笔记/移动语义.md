# 移动语义

移动: 将堆空间的 控制权 转移到其他对象

```c++
class String {
public: 
    String(const char*);
    String(const String&);
    ...;
    String& operator=(const String&);
}

// 等号右侧先调用 C 风格构造函数生成一个临时对象
// 再调用 拷贝构造 / 赋值运算符 函数 把临时对象拷贝给 s1 / s2
// 临时对象 调用析构, 进行销毁

// 此处需要进行 2 次 堆空间的申请

String s1 = "Hello";

String s2;
s2 = "World";
```

1. 右值  
    临时变量 / 临时对象 / 匿名对象 / <mark>字面值常量</mark>

2. 左值引用  
    非 const 左值引用 只可以绑定到 左值  
    const 左值引用可以绑定到 左 / 右 值, 即 **不能区分 左 / 右 值**

3. 右值引用 `int &&rref = ...;`  
    右值引用 只可以绑定 右值, 即 识别右值

## 移动构造函数

1. 参数为右值时, 优先执行 移动构造函数
2. 参数为左值时, 执行拷贝构造函数

```c++
class String {
public: 
    String(const char*);
    String(const String&);

    // 移动构造函数
    // 参数为右值引用
    String(String&& rhs) 
    : _pstr(rhs._pstr) {
        rhs._pstr = nullptr;
    }

private:
    char* _pstr;
}

// 此处 只进行 1 次 堆空间申请
String s1 = "Hello";
```

## 移动复制函数

```c++
class String {
public: 
    String(const char*);
    String(const String&);

    // 赋值运算符函数
    // 参数为右值引用
    // 此处可以不考虑自复制, 因为自复制 等号右侧为 左值, 调用 赋值运算符函数
    // but 仍然需要留着, 解决 std::move (将左值转换为右值)
    // 底层: 强制类型转换 static_cast<T&&>(value)
    String& operator=(String&& rhs) {
        if (this != &rhs) {
            delete [] _pstr;

            _pstr = rhs._pstr;
            rhs._pstr = nullptr;
        }
        return *this;
    }

private:
    char* _pstr;
}

// 此处 只进行 1 次 堆空间申请
String s2;
s2 = "World";

// std::move (将左值转换为右值)
// 底层: 强制类型转换 static_cast<T&&>(value)
// 移动赋值函数, 若没有判断, 则 s2._pstr 会为空
s2 = std::move(s2);
```
