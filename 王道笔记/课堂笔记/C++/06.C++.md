# C++

## 命名空间

1. 中心思想：实现代码隔离
1. 命名空间的作用：
    - **避免命名冲突**：命名空间提供了一种将全局作用域划分为更小的作用域的机制，用于避免不同部分的代码中的命名冲突；
    - 组织代码：命名空间可以用于组织代码，将相关的实体放置到一起；
    - 版本控制：命名空间还可以用于不同的代码版本之间进行隔离；
    - 隐藏的好处：宣誓代码主权
1. 使用方式
    1. 作用域限定符

        - 优点：准确，只要这个命名空间中确实有这个实体，都可以使用作用域限定符 `::` 的方式来访问
        - 缺点：繁琐，跟C语言的方式相似
    1. using 编译指令

        - 优点：简洁
        - 缺点：容易发生冲突, 需要确保明确知道命名空间中有哪些实体，才能做到避免冲突
    1. ==using声明机制==

        - 优点：需要什么就声明什么，可以避免一次引入所有实体，造成冲突
1. 分类
    - 有名空间
    - 匿名空间
        匿名空间中的 变量 不要和 全局变量 冲突
        如果匿名空间中的变量和全局位置的变量发生冲突直接以 `num2` 的形式访问会报错；
        以 `::num2` 的形式访问只会访问到全局变量

## const

**面试常考题**：const常量和宏定义常量有什么区别？

1. 发生的时机不同：C语言中的宏定义常量发生时机是预处理阶段，const 常量是在编译时：
1. 是否有类型检查：宏定义就是简单地进行了字符串的替换，没有类型检查，但是 const 修饰的常量本质是变量，有类型检查。(所以C++中会更倾向于使用 const 常量，更安全)

## malloc / free / new /delete

**面试常考题**: `malloc/free` 和 `new/delete` 的区别是什么？

1. `malloc/free` 是库函数, `new/delete` 是表达式，不是库函数(后两者也不是函数的写法)

1. `new` 表达式最终的返回值是相应类型的指针(自带类型)`int* p=new int(1)`

   `malloc`  返回值类型是 void*, 还需要进行相应类型的强制转换

1. `malloc`  申请空间时不会进行初始化，获取到的空间中可能存在脏数据：
   `new` 表达式申请空间时，可以显式地初始化(给参数)，也可以隐式地初始化(不给参数)

1. `malloc` 的参数是字节数，new 表达式不需要传递字节数，会根据相应类型自动获取空间。
   `new int(x)` 这样的表达式中，类型后面的参数代表的是初始化的值，如果不给出，就会初始化为该类型的默认值

## 引用 / 指针

**面试常考题**: 谈谈引用和指针的区别与联系

联系:

1. 引用和指针都是用来间接访问变量
1. 引用的底层是使用指针完成的, 可以把引用看成一个受限制的指针

区别：

1. 引用不能单独存在，但是指针可以单独存在(野指针问题)
1. 引用必须初始化，指针可以不初始化：
1. 引用一经绑定便不能修改绑定，但是指针可以随意修改指向，非常灵活(灵活意味着强大，也意味着容易出错一引用的设计初衷就是希望程序员少用指针)
1. 引用筒单理解为不额外占据内存，引用的地址即变量本身的地址，而指针在内存中占据的空间是存储地址所需要的字节数

## C++ 强制转换

C 中强制转换为万能写法, C++ 进行了削弱了, 使其更合理, 例如禁止 `const char* -> int*` 的转换

1. `static_cast` 主要掌握

   `static_cast<目标类型>(转换的对象)`

   好处

   - 阻止不合法的转换
   - 方便查找 `grep static_cast * -rn`

1. `const_cast` 去除 const 属性，了解即可

1. `dynamic_cast` 多态的时候学

1. `reinterpret_cast` 最强大，慎用

## 函数重载

实现原理: **名字改编**(name mangling)一一当函数名称相同时，会根据参数的类型、顺序、个数进行改编
`nm xxx.o` 查看 ???

## C++ 中嵌入 C 代码

```c
// 大括号中插入 C 代码, 编译器按照 C 的方式调用, 不再进行名字改编, 可以提高效率
extern "C" {
    ...;
    ...;
}
```

## inline

`inline` 函数若在头文件声明, 则必须在头文件定义

## 内存布局

**面试重点**:

![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202309051546758.png)

1. 栈区：最顶层是栈区，函数入栈就是在这个区域，函数入栈表示要去这片空间中创建一些变量(函数栈空间)
1. ==堆区==：通过 `malloc` 或者 `new` 创建的内容就在堆区
1. ==全局静态区==：全局变量、静态变量, *命名空间中的变量* 一 **读写**
1. 文字常量区：字符串常量(文字常量)一 **只读**
1. 程序代码区：函数体的二进制代码 一 **只读**

## C 风格字符串

```const char* p = ...
// 推荐
const char* p = ...;
```

## 面向对象

1. 类名一般遵循 **大驼峰** 规则
1. 成员函数名遵循 **小驼峰** 规则
1. 数据成员通常以 **_** 开头
1. 先写 private, 放于下方; 再写 public, 放于上方
1. 如果在类中 定义成员函数, 则成员函数默认为 inline 函数
1. 如果在头文件中完成 类成员函数的分离定义, 需要将其设为内联函数, 避免多文件编译错误

## struct / class

1. C 中的 struct 只能是一些变量的集合体，可以封装数据但是不能隐藏数据。而且成员不能是函数，要使用函数只能通过函数指针的方式。访问权限的限制、继承性、构造析构这些都没有
1. C++ 中的 struct 相当于 C 中结构体的拓展, 可以在内部进行函数声明/定义; 内容上与 class 类似, 但是访问权限为 public

## class 初始化列表

为了应对一些特殊类型的数据成员的初始化(引用 / const), 把数据成员的初始化放在构造函数和函数体之间, 以 ==:== 开始，每个数据成员的初始化以 ==,== 隔开, 通常每个数据成员单独占一行

初始化顺序: 与声明顺序一致

## 对象所占空间大小

因为一些平台只能在某些特定地址去进行寻址，如果不对齐的话可能需要二次寻址，会降低效率，所以会隐式地进行==内存对齐==

不考虑继承多态时，对象所占空问的大小和数据成员的大小、顺序有关

除数组外，其他类型的数据成员中，以较大的数据成员所占空间的倍数去对齐。 对象所占的大小和成员函数无关。

## 构造函数规则

1. 类中没有显式给出构造函数，会自动提供一个默认的无参构造，但不会初始化数据成员
1. 类中显式写出了构造函数，系统就不会再自动提供默认构造函数
1. 如果还希望通过默认构造函数创建对象，需要手动提供一个默认构造函数
1. 构造函数可以重载

## 析构函数

1. **对象被销毁时, 自动调用**
1. 作用: **清理类对象成员申请的资源(==堆空间==)**
1. 形式:

    1. 无返回值
    1. 无参数
    1. 函数名: `~类名`
    1. 只能有一个, **不能重载**
1. 显式调用析构函数不会销毁对象(栈空间任然存在)

    1. 输出流运算符输出 char 型空指针会导致程序崩溃

![image-20230906114309735](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/image-20230906114309735.png)

## 析构函数调用时机

1. 栈对象生命周期结束时，会自动调用析构函数
1. **全局**对象在main函数退出时，会自动调用析构函数
1. **静态**对象在main函数退出时，会自动调用析构函数
1. **堆对象当执行delete表达式时，会自动调用析构函数**
    delete语句会先调用析构函数回收 Apple 这片空间，再通过 operator delete 回收堆对象本身的空间
1. 同一层次的 **先创建后销毁**

## 拷贝构造函数

1. 形式: `类名(const 类名& xxx)`

1. 对象的数据成员申请了 **堆上** 的空间，那么拷贝构造就需要采用深拷贝的方式，先申请足够大的空间，在把堆上的内容复制过来

1. 拷贝构造函数的调用时机(**`面试??重点`**) -------> **3**

    > 1. 当使用一个已经存在的对象 初始化 另一个同类型的新对象时
    > 1. 当函数参数(实参和形参)的类型都是对象，形参与实参结合时(实参初始化形参)------ **按值传递对象**, 可以使用引用解决
    > 1. 当函数的返回值是对象，执行 return 语句时(编译器有**优化**) -----> 返回的实际是新对象的引用 ???
    >    `-fno-elide-constructors` 编译时取消优化
    >    为了避免这次多余的复制，可以使用 引用 作为函数的返回值, 但是要注意引用所绑定的对象的声明周期要比函数更长(static)

1. 注意:
    1. 与 重载赋值运算符 区分 ------>
    1. 参数中 `&` 不能去掉, 否则会触发第二种调用, 造成递归调用, 直到栈溢出
    1. 参数值 `const` 不能去掉, 否则无法使用 临时对象(右值) 构造 新对象; 并且可以保证右操作数的数据成员不被改变
        - const 引用绑定右值时会生成一个临时的 const 对象
        - 原理: 右值引用 `&&`

        ```c++
        // 此处 5 为右值, 会报错
        int& x = 5;
        
        // 将 引用 类型设为 const, 
        const int& x = 5;
        ```

## 重载赋值运算符

1. 形式: `类名& operator=(const 类名& ...)` / `return *this`
1. 赋值运算符函数不能使用初始化列表
1. 问题: 无法解决自复制 -------> 函数内增加判断 `if (this != &...)`
1. 步骤 (**`面试??重点`**):
    1. 考虑自复制
    1. 回收堆空间
    1. 深拷贝(开辟空间再复制)以及其他的数据成员的复制
    1. 返回 this
1. 注意
    1. 返回值不能为 `类`, 会多调用一次 拷贝构造函数
    1. 返回值不能为 `void`, 无法解决连续赋值的问题
    1. 参数不能为 `const 类 ...`, 会多调用一次 拷贝构造函数
    1. 参数不能为 `类& ...`
        1. 避免赋值过程中修改右操作数的成员
        1. 可以应对临时对象的赋值
        1. 可以实现不同类型对象之间的赋值
1. 三合成原则(**`面试???重要`**): 拷贝构造 / 赋值 / 析构函数，如果手动定义其中的一个，另外两个也需要手动定义

## this 指针

1. this 指针会隐式地成为成员函数的第一个参数
1. this 指针需要确保的是一定指向本对象
1. this 指针的形式：`类名* const this`

## 特殊的数据成员初始化

1. const成员: 初始化列表中初始化, C++11 支持声明时初始化, 但是不推荐
1. 引用成员: 初始化列表中初始化, C++11 支持声明时初始化, 但是不推荐; 确保引用数据成员绑定到已存在变量, 不能把非 const 引用 绑定到一个临时对象
1. 对象成员: **必须在初始化列表中初始化**; 如果没有显式地在初始化列表中初始化对象成员，那么会自动调用对象成员类的默认无参构造
1. **`静态成员`**
    1. 存储的位置在**全局静态区**，不属于对象布局的一部分
    1. 静态成员被整个类的所有对象**共享**
    1. private 的静态变量 在类之外无法被访问, 但是可以在类外面进行初始化, 且只能在外面进行初始化; 初始化时不需要加 `static` 关键字, 但需要加上 `类名::静态变量`
    1. 静态数据成员的初始化顺序和声明顺序一致, 避免依赖问题

## 特殊成员函数

1. 静态成员函数

    1. 在某一个成员函数的前面加上 static 关键字不能是 **构造**函数/**析构**函数/**赋值**运算符函数/**拷贝**构造 (因为这四个函数都会访问所有的数据成员，而 static 成员函数**没有this指针**)
    1. 可以通过 `类名::函数名()` 来调用, **不依赖于具体的对象**; 也可以通过对象来调用, 但不常用
    1. 静态的成员函数不能访问非静态的数据成员(**没有 this 指针**), 也不能调用非静态成员函数(构造例外)
1. const 成员函数
    1. **参数列表后, 函数执行体前**加 const
    1. 不能修改对象的数据成员
    1. 当编译器发现该函数为 const 成员函数时，会自动将 this 指针设置为双重const 限定的指针, `const 类名* const ...`
    1. 当类中有 const 成员函数 和 非 const 成员函数构成函数重载时，只有const对象才/只能调用 const 版本的成员函数
    1. 当类中只有一个 const 版本的成员函数时, 不管是 const 对象还是 非const 对象都能调用 const 成员函数
    1. **总结**: 如果类中的某一个成员函数可以确定不修改数据成员, 则把它设为 const 成员函数

## new 表达式工作步骤

1. 调用 `operator new` 标准函数 申请 **未类型化** 的空间, 底层 `malloc`

    `void* operator new(size_t sz);`

1. 在该空间调用 **构造函数** 初始化对象的 数据成员

1. 返回一个相应类型的指针

## delete 表达式工作步骤

1. 调用**析构函数**, 回收数据成员申请的资源

1. 调用 `opeartor delete` 库函数 回收本对象所在的空间, 底层 `free`

    `void operator delete(void* p);`

## 创建堆对象

1. 需要合法的 operator new、operator delete函数、构造函数;
1. 对 析构函数 无要求
1. 类: 只能生成堆对象 ------> 将 析构函数 设为 private

## 创建栈对象

1. 需要合法的 构造函数, 析构函数
1. 类: 只能生成栈对象 ------> 将 new / delete 其中之一 设为 private

## 单例模式 (**`面试重点`**)

一个类只能生成一个对象, 且是唯一对象

静态区域生成单例对象:

1. 构造函数私有
1. 提供一个static成员创建 static对象，返回它的引用
1. 全局静态区较小, 会造成较大压力

```c
//当静态函数多次被调用，静态的局部对像只会初始化一次
//第一次调用时，静态对象会被初始化为一个对象实例
//后续的调用中，静态局部对象已经存在，不会再初始化而是直接返回已经初始化的对象实例

static Point& getInstance() {
    static Point pt(1,2); 
    return pt;
}

static void destory() {
    if (_pInstance) {
        // 此处 delete 为 类的成员函数
        // 会先调用析构函数, 回收 数据成员申请的堆空间
        // 再使用 delete 删除对象的空间 
        delete _pInstance; 
        _pInstance = nullptr;
    }
}


// 从类中 删除 拷贝构造函数 / 赋值运算符重载
Point(const Point &) = delete;
Point& operator=(const Point&) = delete;

// 析构函数的访问权限一般与构造函数相同或更严格

// 
static Point* _pInstance;
```

在堆上创建单例对象

1. 构造 / 析构函数 私有; 拷贝构造 / 赋值运算符 `delete`; 添加 `static` 数据成员, 为指向对象的指针, 在main 前初始化
1. 使用 static 成员函数，去创建对象，返回值为 `Point*`  类型的指针; 做判断，第一次时创建，后续调用直接返回这个指针
1. 添加 `init` 成员函数，修改对象的数据成员(把创建和赋值分离)
1. 添加 `destory` 成员函数, 回收堆对象使用static成员函数，在这个成员函数中使用delete表达式回收

应用场景:

1. 用单例模式替换全局变量
1. 有频繁实例化然后销毁的情况，也就是频繁的new对象，可以考虑单例模式
1. 创建对象时耗时过多或者耗资源过多，但又经常用到的对象：

- [x] 创建 / 删除 堆上对象时的 new / delete 与 类中重载的 new / delete 是否为同一个
