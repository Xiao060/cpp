# 移动语义

1. 移动: 将堆空间的 控制权 转移到其他对象

2. 将 拷贝构造 / 赋值运算符函数 称为具有 **拷贝控制语义** 的函数
3. 将 移动构造 / 移动赋值函数 称为具有 **移动语义** 的函数
4. 具有 移动语义的函数 优先于 具有拷贝语义的函数

```c++
class String {
public: 
    String(const char*);
    String(const String&);
    ...;
    String& operator=(const String&);
}

// 等号右侧先调用 C 风格构造函数生成一个临时对象
// 再调用 拷贝构造 / 赋值运算符 函数 把临时对象拷贝给 s1 / s2
// 临时对象 调用析构, 进行销毁

// 此处需要进行 2 次 堆空间的申请

String s1 = "Hello";

String s2;
s2 = "World";
```

1. 右值  
    临时变量 / 临时对象 / 匿名对象 / <mark>字面值常量</mark>

2. 左值引用  
    非 const 左值引用 只可以绑定到 左值  
    const 左值引用可以绑定到 左 / 右 值, 即 **不能区分 左 / 右 值**

3. 右值引用 `int &&rref = ...;`  
    1. 右值引用 只可以绑定 右值, 即 识别右值
    2. 右值引用 可以是 右值 也可以为 左值  
        右值引用 作为 返回值 时, 其为右值  
        右值引用变量 为 左值

        ```c++
        // x 此处为 左值
        int&& x = 5;        

        /**********************************/

        int&& f() {
            return 4;
        }

        // 此处 f() 为 右值
        f();
        ```

## 移动构造函数

1. 参数为右值时, 优先执行 移动构造函数
2. 参数为左值时, 执行拷贝构造函数

```c++
class String {
public: 
    String(const char*);
    String(const String&);

    // 移动构造函数
    // 参数为右值引用
    String(String&& rhs) 
    : _pstr(rhs._pstr) {
        rhs._pstr = nullptr;
    }

private:
    char* _pstr;
}

// 此处 只进行 1 次 堆空间申请
String s1 = "Hello";
```

## 移动复制函数

1. 考虑自移动
2. 删除
3. 浅拷贝
4. 返回 `*this`

```c++
class String {
public: 
    String(const char*);
    String(const String&);

    // 赋值运算符函数
    // 参数为右值引用
    // 此处可以不考虑自复制, 因为自复制 等号右侧为 左值, 调用 赋值运算符函数
    // but 仍然需要留着, 解决 std::move (将左值转换为右值)
    // 底层: 强制类型转换 static_cast<T&&>(value)
    String& operator=(String&& rhs) {
        // 1. 考虑自移动
        if (this != &rhs) {
            delete [] _pstr;

            _pstr = rhs._pstr;
            rhs._pstr = nullptr;
        }
        return *this;
    }

private:
    char* _pstr;
}

// 此处 只进行 1 次 堆空间申请
String s2;
s2 = "World";

// std::move (将左值转换为右值)
// 底层: 强制类型转换 static_cast<T&&>(value)
// 移动赋值函数, 若没有判断, 则 s2._pstr 会为空
s2 = std::move(s2);
```

## std::move

1. 作用: 将左值转换为右值
2. 底层: 强制类型转换 `static_cast<T &&>(value)`

## <mark>RAII</mark> (重要)

资源获取及初始化

1. 常见特征 (步骤)
    1. 构造函数中初始化资源
    2. 析构函数中释放资源
    3. 一般不允许 拷贝 / 赋值(对象语义) <----> 值语义: 允许 拷贝 / 赋值
        1. 将 拷贝 / 赋值函数设为 **私有**
        2. 将 拷贝 / 赋值函数设为 **delete**
        3. 使用 **继承** 的方法, 将基类 拷贝 / 赋值 delete
    4. 提供若干访问资源的方法

2. 本质  
    利用 栈对象的生命周期 来管理资源, 因为栈对象在离开作用域时, 会自动调用析构函数

3. 关键  
    要保证资源的释放顺序与获取顺序严格相反

```c++
// 完成对象语义的 基类
class NonCopyable {
public:
    NonCopyable() = default;
    ~NonCopyable() = default;

    NonCopyable(const NonCopyable& rhs) = delete;
    NonCopyable& operator=(const NonCopyable& rhs) = delete;
}

template <typename T>
class RAII 
: NonCopyable {
public:
    // 1. 构造函数中 申请资源
    RAII(T* data) 
    : _data(data) {}

    // 2. 析构函数中 释放资源
    ~RAII() {
        if (_data) {
            delete _data;
            _data = nullptr;
        }
    }

    // 3. 一般不允许 拷贝 / 赋值
    // 私有 / delete / 继承无拷贝赋值的基类 

    // 4. 提供若干访问资源的方法
    T* get() { return _data; }
    T* operator->() { return _data; }
    T& operator*() { return *_data; }

    void reset(T* data) {
        if (_data) {
            delete _data;
            _data = nullptr;
        }
        _data = data;
    }

private:
    T* _data;
};
```

## 智能指针

`include <memory>`

### `std::auto_ptr`

```c++
auto_ptr<int> ap(new int(10));
```

1. 只能接收左值

### `std::unique_ptr`

### `std::shared_ptr`

### `std::weak_ptr`
