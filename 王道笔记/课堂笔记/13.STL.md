# STL  

(标准模板库, Standard Template Library)

## 容器

### 序列式容器

#### 初始化

|     | vector | deque | list |
| --- | :---: | :---: | :---: |
| 无参 | √ | √ | √ |
| count 个 value | √ | √ | √ |
| 迭代器范围 | √ | √ | √ |
| 拷贝/移动 构造 | √ | √ | √ |
| 初始化列表 (大括号) | √ | √ | √ |

#### 遍历

|     | vector | deque | list |
| --- | :---: | :---: | :---: |
| 下标 | √ | √ | <mark>×</mark> |
| 迭代器 | √ | √ | √ |
| 增强 for 循环 (依托 迭代器) | √ | √ | √ |

#### 基本操作

|     |     | vector | deque | list |
| --- | --- | :---: | :---: | :---: |
|     | push_front() | <mark>×</mark> | √ | √ |
|     | pop_front() | <mark>×</mark> | √ | √ |
|     |  |  |  |  |
| 就地插入, 避免拷贝 | emplace_back() | √ | √ | √ |
| 有可能拷贝 | push_back() | √ | √ | √ |
|     | pop_back() | √ | √ | √ |
|     |  |  |  |  |
|     | insert() | √ | √ | √ |
|     |  |  |  |  |
|     | erase() | √ | √ | √ |
|     |  |  |  |  |
|     | resize() | √ | √ | √ |
|     |  |  |  |  |
|     | swap() | √ | √ | √ |
|     |  |  |  |  |
|     | clear() | √ | √ | √ |
|     | capacity() | √ | <mark>×</mark> | <mark>×</mark> |
| 回收未使用空间 | shrink_to_fit() | √ | √ | <mark>×</mark> |
| 预留空间, 防止频繁扩容 | reserve() | √ | √ | √ |
| 获取第一个元素的地址 | data() | √ | √ | √ |
|     |  |  |  |  |
|     | reverse() |  |  | √ |
|     | sort() |  |  | √ |
| 移除连续重复元素 | unique() |  |  | √ |
| 合并两有序链表 | merge() |  |  | √ |
|     | splice() |  |  | √ |

1. 为何 vector 不支持在头部进行插入与删除呢?  

    vector中的元素是连续的, 如果在头部进行插入与删除的时间复杂度比较高 O(n)

2. `insert()`

    1. 插入方式

        1. 找一个位置插入 1 个元素

        2. 找一个位置插入 count 个 value

        3. 找一个位置插入 迭代器范围的元素

        4. 找一个位置插入 大括号范围的元素

    2. deque 插入存在 前半部分 与 后半部分 的概念

    3. vector 迭代器失效 (<mark>重要</mark>)

        1. 概念: 底层发生扩容现象, 而迭代器还指向老的空间, 使用 老的迭代器 去操作 新的空间  

        2. 解决方案: vector 每次插入前重新置位(获取) 迭代器

        3. insert 扩容策略

            size() = m, capacity() = n, 待插入的元素的个数 t
            1. t < n - m; 此时就不会扩容
            2. n - m < t < m; 会按照 2*m 进行扩容
            3. n - m < t, m < t; 会按照 m+t 进行扩容

            push_back 每次插入元素的个数都是固定的 1, 所以按照 两倍 进行扩容肯定容器是足够的;  
            但是 insert 进行插入元素的时候, 元素的个数是不一定的, 所以不能按照某个固定值的两倍进行扩容。

3. `erase()`: 删除元素

    删除元素后 迭代器 不要往后挪, 否则会漏掉某些元素

    ```c++
    for (auto it = x.begin(); it != it.end(); ) {
        if (*it == 7) {
            x.erase(it)
        } else {
            ++it;
        }
    }
    ```

#### vector

![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202309260956926.png)  

![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202309261024551.png)

结论: 在 vector 中随机访问的时候, 可以使用下标, 也可以使用 `at` 函数, 但是下标是没有范围检查的, 所以有可能出现越界的风险, 但是 `at` 函数是有范围检查的, 就没有越界的风险。

```c++
// 获取 vector 第一个元素地址
vector<int> numbet = {...};

&number[0];
&*number.begin();
int* pdata = number.data();
```

#### deque

![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202309261033477.png)  

![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202309261057206.png)

![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202309261104426.png)

特点:

1. 逻辑上连续, 物理上不连续

2. 片段之间是依靠中控器数组进行控制的

#### list

1. `sort()`

    1. 从小到大

        ```c++
        x.sort();
        x.sort(std::less<int>());
        ```

    2. 从大到小

        ```c++
        x.sort(std::greater<int>());
        ```

    3. <mark>自定义类型 排序方式</mark>

        1. 模板的特化

            ```c++
            namespace std{
            template <>
            struct less<Point> {
                bool operator()(const Point& lhs, const Point& rhs) const {
                    // 写出详细的比较流程
                    // ...;
                }
            }
            }
            ```

        2. 运算符重载

        3. 函数对象

            ```c++
            struct CompareList {
                bool operator()(const Point& lhs, const Point& rhs) const {
                    // 写出详细的比较流程
                    // ...;
                }
            }
            x.sort(CompareList);
            ```

2. `merge`

    merge的时候, 两个链表最好都按照从小到大进行排序, 否则合并到一起之后, 就不是有序的

3. `splice()`

    1. 将 number3 中的所有元素都移动到 number 中

        ```c++
        number.splice(it, number3);
        ```

    2. 将 number3 中的 nit 指向的元素移动到 number 中

        ```c++
        number.splice(it, number3, nit);
        ```

    3. 将 number3 中的 nit 到 nit2 范围的元素移动到 number 中

        ```c++
        // 可以在同一个链表中进行 splice 操作, but 如果移动范围交叉
        number.splice(it, number3, nit, nit2);
        ```

### 关联式容器  

#### set

1. 不支持下标访问

2. 底层实现为 红黑树, 为了维护红黑树的稳定性, 不支持 修改操作

3. `insert()` 返回值为 `pair`

#### multiset

相同点

1. 不支持下标访问

2. 底层实现为 红黑树, 为了维护红黑树的稳定性, 不支持 修改操作

3. `count() / find() / erase()` 操纵相同

4. 针对 自定义类型 的 Compare, 都支持 <mark>模板特化/运算符重载/函数对象</mark>

不同点

1. key 值不唯一

2. `insert()` 插入 1 个元素, 返回值为 迭代器

3. `equal_range`

4. `lower_bound` 返回首个 >= 给定值的迭代器

5. `upper_bound` 返回首个 > 给定值的迭代器

#### map

1. 特征

    1. 存放的是 key-value 类型，key 值是唯一的

    2. 默认会按照 key 值进行升序排列

    3. 底层实现也是使用红黑树

2. 初始化

    1. `pair<xxx>(xxx, xxx)`

    2. `{xxx, xxx}`

    3. `make_pair(xxx, xxx)`

3. 下表访问  

    具备 查找 / 插入 / 修改 的功能, 但是没有 const 版本

#### multimap

### 无序关联式容器  

unordered_set/unordered_map

## 迭代器

广义/泛型指针, 容器 与 算法之间的桥梁

## 适配器

1. 容器的适配器: stack/queue/priority_queue(优先级队列)

2. 迭代器的适配器

3. 函数适配器

## 算法

## 函数对象(仿函数)

定制化操作, 例: 删除器

## 空间配置器

进行空间的申请与释放
