# 09.19

## 1

什么是多态？虚函数的实现原理是什么?

## 2

什么是重载？什么是隐藏？什么是覆盖？他们之前的区别是？

## 3

根据给定的程序，写出执行结果

```c++
class A {
public:
    void FuncA() {
        printf( "FuncA called\n" );
    }

    virtual void FuncB() {
        printf( "FuncB called\n" );
    }
};

class B 
: public A {
public:
    void FuncA() {
        A::FuncA();
        printf( "FuncAB called\n" );
    }
    
    virtual void FuncB() {
        printf( "FuncBB called\n" );
    }
};

int main( void ) {
    B b;
    A *pa;
    pa = &b;
    A *pa2 = new A;
    pa->FuncA();            // (3) 
    pa->FuncB();            // (4)
    pa2->FuncA();           // (5)
    pa2->FuncB();
    delete pa2;

    return 0；
}

/*
// (3) pa 为指向基类的指针, 只能操作基类部分的数据, 故 (3) 调用的实际是 基类的 FuncA
// (4) 因为 基类中 FuncB 是一个虚函数, 所以会根据 虚函数指针 查 虚表, 从而找到虚函数的入口地址;
// but 虚表中的 基类的FuncB 的入口函数地址 被派生类中的  FuncB 地址覆盖了, 所以找到的其实是 派生类的 FuncB

FuncA called
FuncBB called
FuncA called
FuncB called
*/
```

## 4

根据给定的程序，写出执行结果

```c++
class Base {
public:
    Base(int j)
    : i(j) {}

    virtual  ~Base() {}
    
    void func1() {
        i *= 10;
        func2();
    }
    
    int getValue() {
        return  i;
    }
    
protected:
    virtual void func2() {
        i++;
    }
    
protected:
    int i;
};

class Child
: public Base {
public:
    Child(int j)
    : Base(j) {
        
    }

    void func1() {
        i *= 100;
        func2();
    }
    
protected:
    void func2() {
        i += 2;
    }
};

int main() {
    Base * pb = new Child(1);
    pb->func1();
    cout << pb->getValue() << endl; 
    
    delete pb; 
    
    return 0；
} 
```
