# 继承

## 概述

1. 继承的局限(不能继承)
    1. 构造 / 析构函数
    2. 拷贝构造
    3. 用户重载的 `operator=` 运算符
    4. 用户重载的 `operator new` / `delete` 运算符
    5. 友元关系

2. 派生(继承)方式

    1. `public` 公有继承 (接口继承: 派生类对象可以访问基类接口)

    2. `protected` 保护继承 (实现继承)

    3. `private` 私有继承 (实现继承)
        ![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202309151721192.png)

3. 步骤
    1. 吸收基类的成员

    2. 添加自己新的成员 (非必需)  
        派生类可以不添加新的成员、不实现新的功能, 这样的派生类称为空派生类, 其目的是在一些特定场景下建立继承关系, 为将来的拓展留出空间

    3. 改造基类的成员 (非必需)  

        1. 若 派生类中 存在与 基类中 <mark>同名</mark> 的数据成员, 派生类对象 直接访问得到的是 派生类成员; 若想访问基类成员, 则需要加 `xxx.类名::xxx` (注意不是覆盖)

        2. 基类成员函数的 **隐藏(oversee)**  ------> 不推荐  
            派生类定义了 与 基类中成员函数 <mark>**同名**</mark> 的成员函数, 即使参数列表不同，也只能访问到派生类的成员函数;  

            若没有定义同名函数, 则 可访问到 基类的成员函数  

            与函数重载是有区别的，函数重载是在 **同一个类作用域中**，函数的隐藏是发生在 **基类派生类之间** (两个类作用域)

4. 创建 派生类对象 时调用 基类构造 的机制

    1. 先调用派生类构造函数, 再调用基类构造函数; 先构造基类部分, 再构造派生类部分

    2. 派生类的构造函数若没有显式调用基类的构造函数, 则创建派生类对象时会自动调用 无参构造; 若基类无 无参构造, 则派生类创建失败

    3. 当派生类对象调用基类构造时, 希望使用非默认的基类构造函数, 必须显式地在初始化列表中写出

5. <mark>构造函数 执行顺序</mark>

    1. 先执行 基类 的 构造函数

    2. 再执行 成员子对象 的构造函数

    3. 最后执行 派生类 的构造函数

6. <mark>析构函数 执行顺序</mark>

    1. 先执行 派生类对象 的析构函数

    2. 执行完之后执行 成员子对象 的析构函数

    3. 最后执行 基类子对象 的析构函数  

        ![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202309181130840.png)

7. 总结

    1. 派生类在类之外对于基类成员的访问，具有什么样的限制？  

        只有公有继承自基类的公有成员，可以通过派生类对象直接访问，其他情况一律都不可以进行访问

    2. 派生类在 类内部 对于基类成员的访问，具有什么样的限制？  

        对于基类的私有成员，不管以哪种方式继承，在派生类内部都不能访问;  

        对于基类的非私有成员，不管以愿种方式继承，在派生类内部都可以访问;

    3. 保护继承 和 私有继承的区别？  

        如果继承层次中都采用的是保护继承，任意层次都可以访问顶层基类的非私有成员;  

        但如果采用私有继承之后，这种特性会被打断.

## 多重继承

1. 概述
    1. 多重继承每个类都要写明 继承方式, 否则默认为 private 私有继承

    2. 多重继承时 先调用 派生类 的构造函数, 然后按照 <mark>初始化列表顺序</mark> 调用 各基类的构造函数

    3. 先调用 派生类的 析构函数, 各基类的 析构顺序 与 构造顺序 相反

2. 问题

    1. 成员名访问冲突二义性  

        若 <mark>多个基类</mark> 中存在 <mark>同名函数</mark>, 派生类对象调用时会发生 成员名访问冲突二义性, 可以使用 <mark>作用域限定运算符</mark> 解决;  

        若 派生类 中也存在同名函数, 会发生 <mark>隐藏(oversee)</mark>, 不会冲突

    2. 存储二义性 (菱形/钻石继承)  
        ![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202309181507014.png)
        ![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202309181524906.png)  

        派生类存在多个 间接基类 的子对象, 当调用 间接基类的成员函数时 无法确定选择哪个 子对象  

        方案：<mark>中间层</mark>的基类采用 <mark>虚继承方式</mark> 解决存储二义性  

        ![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202309181525144.png)

3. 基类 与 派生类 转换

    1. 空间大小

        1. 一般 基类对象 占据的空间 小于 派生类

        2. 空派生/内存对齐 情况下, 基类对象 和 派生类对象 所占空间相同

    2. 向上转型安全, `基类对象  指针/引用 = 派生类...`

    3. 向下转型有风险(强制类型转换), but 编译器不会报错, 使用 dynamic_cast 解决(需要基类中有 **多态内容(虚函数)**)

        1. `dynamic_cast<派生类*>(基类*)`, 转换失败返回 空指针

4. 派生类对象 间的 复制 (拷贝/赋值)

    1. 原则: 基类部分与派生类部分单独处理

    2. 若 派生类没有显式定义 复制控制函数, 会自动完成基类部分的复制 <mark>??????</mark>

    3. 若 派生类显式定义 复制控制函数, 则基类的复制控制需要 显式调用(手动写出) <mark>??????</mark>

        ```c++
        // 拷贝构造
        Derived(const Derived& rhs) 
        : Base(rhs)                 // 向上转型
        , _derived(rhs._derived) {
        }

        // 赋值运算符
        Derived& operator=(const Derived& rhs) {
            // 向上转型
            Base::opertor=(rhs);        
            _derived = rhs._derived;
            return *this;
        }
        ```
