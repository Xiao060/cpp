# 面试题

## 3.sizeof 和 strlen 的区别

1. sizeof 是一个操作符，strlen 是库函数。

2. sizeof 的参数可以是数据的类型，也可以是变量，而 strlen 只能以结尾为 '\0' 的字符串作参数。

3. 编译器在编译时就计算出了sizeof 的结果。而 strlen 函数必须在运行时才能计算出来。并且 sizeof 计算的是数据类型占内存的大小，而 strlen 计算的是字符串实际的长度。

4. 数组做sizeof的参数不退化，传递给strlen就退化为指针了。

注意：有些操作符看起来像是函数，而有些函数名看起来又像操作符，这类容易混淆的名称一定要加以区分，否则遇到数组名这类特殊数据类型作参数时就很容易出错。最容易混淆为函数的操作符就是sizeof。

## 5.Ｃ中的 malloc 和Ｃ++中的 new 有什么区别

1. new、delete是操作符，可以重载，只能在C++中使用。

2. malloc、free是函数，可以覆盖，C、C++中都可以使用。

3. new可以调用对象的构造函数，对应的delete调用相应的析构函数。

4. malloc仅仅分配内存，free仅仅回收内存，并不执行构造和析构函数

5. new、delete返回的是某种数据类型指针，malloc、free返回的是void指针。

注意：malloc申请的内存空间要用free释放，而new申请的内存空间要用delete释放，不要混用。因为两者实现的机理不同。

## 8.a 和 &a 有什么区别

注意：数组名a可以作数组的首地址，而&a是数组的指针。对比上两式子的不同。

a+1, a代表数组a的首地址，1代表数组a中1个元素的长度，为4个字节。

&a+1, &a为代表a数组的指针，1根据&a变化代表了int a[5]数组的大小，为4*5=20个字节。

## 9.简述C、C++程序编译的内存分配情况

1. 从静态存储区域分配：  
   内存在程序编译时就已经分配好，这块内存在程序的整个运行期间都存在。速度快、不容易出错，因为有系统会善后。例如全局变量，static变量等。

2. 在栈上分配：  
   在执行函数时，函数内局部变量的存储单元都在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。

    工作中讨论问题都叫栈变量。

3. 从堆上分配：  
   即动态内存分配。程序在运行的时候用malloc或new申请任意大小的内存，程序员自己负责在何时用free或delete释放内存。动态内存的生存期由程序员决定，使用非常灵活。如果在堆上分配了空间，就有责任回收它，否则运行的程序会出现内存泄漏，另外频繁地分配和释放不同大小的堆空间将会产生堆内碎块。

一个C、C++程序编译时内存分为5大存储区：堆区、栈区、全局/静态区、文字常量（字符常量）区、程序代码区。

## 13.C++的空类有哪些成员函数

1. 缺省构造函数。
2. 缺省拷贝构造函数。
3. 缺省析构函数。
4. 缺省赋值运算符。
5. 缺省取址运算符。
6. 缺省取址运算符 const。

注意：有些书上只是简单的介绍了前四个函数。没有提及后面这两个函数。但后面这两个函数也是空类的默认函数。另外需要注意的是，只有当实际使用这些函数的时候，编译器才会去定义它们。

## 14.谈谈你对拷贝构造函数和赋值运算符的认识

1. 拷贝构造函数生成新的类对象，而赋值运算符不能。

2. 由于拷贝构造函数是直接构造一个新的类对象，所以在初始化这个对象之前不用检验源对象是否和新建对象相同。而赋值运算符则需要这个操作，另外赋值运算中如果原来的对象中有内存分配要先把内存释放掉

注意：当有类中有指针类型的成员变量时，一定要重写拷贝构造函数和赋值运算符，不要使用默认的。

## 17.简述类成员函数的重写、重载和隐藏的区别

1. 重写和重载主要有以下几点不同  
   范围的区别：被重写的和重写的函数在两个类中，而重载和被重载的函数在同一个类中  
   参数的区别：被重写函数和重写函数的参数列表一定相同，而被重载函数和重载函数的参数列表一定不同  
   virtual的区别：重写的基类中被重写的函数必须要有virtual修饰，而重载函数和被重载函数可以被virtual修饰，也可以没有。

2. 隐藏和重写、重载有以下几点不同  
   与重载的范围不同：和重写一样，隐藏函数和被隐藏函数不在同一个类中  
   参数的区别：隐藏函数和被隐藏的函数的参数列表可以相同，也可不同，但是函数名肯定要相同。当参数不相同时，无论基类中的参数是否被virtual修饰，基类的函数都是被隐藏，而不是被重写  
   说明：虽然重载和覆盖都是实现多态的基础，但是两者实现的技术完全不相同，达到的目的也是完全不同的，覆盖是动态态绑定的多态，而重载是静态绑定的多态。

## 18.简述多态实现的原理

编译器发现一个类中有虚函数，便会立即为此类生成虚函数表 vtable。虚函数表的各表项为指向对应虚函数的指针。编译器还会在此类中隐含插入一个指针vptr（对vc编译器来说，它插在类的第一个位置上）指向虚函数表。调用此类的构造函数时，在类的构造函数中，编译器会隐含执行vptr与vtable的关联代码，将vptr指向对应的vtable，将类与此类的vtable联系了起来。另外在调用类的构造函数时，指向基础类的指针此时已经变成指向具体的类的this指针，这样依靠此this指针即可得到正确的vtable。如此才能真正与函数体进行连接，这就是动态联编，实现多态的基本原理。

注意：一定要区分虚函数，纯虚函数、虚拟继承的关系和区别。牢记虚函数实现原理，因为多态C++面试的重要考点之一，而虚函数是实现多态的基础。

## 19.链表和数组有什么区别

1. 存储形式：数组是一块连续的空间，声明时就要确定长度。链表是一块可不连续的动态空间，长度可变，每个结点要保存相邻结点指针。

2. 数据查找：数组的线性查找速度快，查找操作直接使用偏移地址。链表需要按顺序检索结点，效率低。

3. 数据插入或删除：链表可以快速插入和删除结点，而数组则可能需要大量数据移动。

4. 越界问题：链表不存在越界问题，数组有越界问题。  

说明：在选择数组或链表数据结构时，一定要根据实际需要进行选择。数组便于查询，链表便于插入删除。数组节省空间但是长度固定，链表虽然长度可变但是占了更多的存储空间。

## 21.简述队列和栈的异同

队列和栈都是线性存储结构，但是两者的插入和删除数据的操作不同，队列是“先进先出”，栈是“后进先出”。

注意：区别栈区和堆区。堆区的存取是顺序随意，而栈区是后进先出。栈由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。堆一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收。分配方式类似于链表。

它与本题中的堆和栈是两回事。堆栈只是一种数据结构，而堆区和栈区是程序的不同内存存储区域。

## 32.C++的引用和C语言的指针有什么区别

1. 引用必须被初始化，但是不分配存储空间。指针不声明时初始化，在初始化的时候需要分配存储空间。

2. 引用初始化以后不能被改变，指针可以改变所指的对象。

3. 不存在指向空值的引用，但是存在指向空值的指针。

注意：引用作为函数参数时，会引发一定的问题，因为让引用作参数，目的就是想改变这个引用所指向地址的内容，而函数调用时传入的是实参，看不出函数的参数是正常变量，还是引用，因此可能会引发错误。所以使用时一定要小心谨慎。

 
## 33.typedef和define有什么区别

1. 用法不同：typedef用来定义一种数据类型的别名，增强程序的可读性。define主要用来定义常量，以及书写复杂使用频繁的宏。

2. 执行时间不同：typedef是编译过程的一部分，有类型检查的功能。define是宏定义，是预编译的部分，其发生在编译之前，只是简单的进行字符串的替换，不进行类型的检查。

3. 作用域不同：typedef有作用域限定。define不受作用域约束，只要是在define声明后的引用都是正确的。

4. 对指针的操作不同：typedef和define定义的指针时有很大的区别。

注意：typedef定义是语句，因为句尾要加上分号。而define不是语句，千万不能在句尾加分号。


## 36.关键字const是什么
const用来定义一个只读(不能修改其值)的变量或对象。  

主要优点：便于类型检查、同宏定义一样可以方便地进行参数的修改和调整、节省空间，避免不必要的内存分配、可为函数重载提供参考。

const 应用表现在：常量定义；类的成员变量为常量；类的成员函数为常量（表示该函数不能修改成员变量的值）；函数传递的时候参数为常量。

说明：const修饰函数参数，是一种编程规范的要求，便于阅读，一看即知这个参数不能被改变，实现时不易出错。


## 37.static有什么作用
static在C中主要用于定义全局静态变量、定义局部静态变量、定义静态函数。在C++中新增了两种作用：定义静态数据成员、静态函数成员。

注意：因为static定义的变量分配在静态区，所以其定义的变量的默认值为0，普通变量的默认值为随机数，在定义指针变量时要特别注意。

 
## 38.extern有什么作用
extern标识的变量或者函数声明其定义在别的文件中，提示编译器遇到此变量和函数时在其它模块中寻找其定义。

 

## 39.简述指针常量与常量指针区别
指针常量是指定义了一个指针，这个指针的值只能在定义时初始化，其他地方不能改变。常量指针是指定义了一个指针，这个指针指向一个只读的对象，不能通过常量指针来改变这个对象的值。

指针常量强调的是指针的不可改变性，而常量指针强调的是指针对其所指对象的不可改变性。

注意：无论是指针常量还是常量指针，其最大的用途就是作为函数的形式参数，保证实参在被调用函数中的不可改变特性。

举例如下：
```c++
int main() {

    int ival = 55;
    int jval = 38;

    //pa为指向常量的指针,不能通过pa改变其指向的ival的值
    // 但pa可以指向其他变量
    // [常量指针==指针指向的值为常量]
    const int *pa= &ival;
 
    //报错：l-valuespecifies const object
    // *pa = 88;        

    pa = &jval;
    cout << *pa << endl;  //正确. 38

    // pb为常量，指向变量的指针,pb不能修改
    // 但可以修改pb指向的值。
    // [指针常量==指针本身是个常量]
    int* const pb= &ival;
    // pb = &jval;
    // cout << *pb << endl;  //l-value specifies const object

    *pb = 2012;
    cout <<*pb << "\t" << ival << endl; //2012 2012

    //pc针对上述两种修改都不可以。
    const int*const pc = &ival;
    cout <<*pc << endl;      //2012

    return 0;
}
```
 

## 41.数组名和指针的区别
请写出以下代码的打印结果：
```c++
void main(void) {

    char str[13]="Hello world!";
    char* pStr="Hello world!";
 
    cout<<sizeof(str)<<endl;  //13
    cout<<sizeof(pStr)<<endl;//4
    cout<<strlen(str)<<endl;  //12
    cout<<strlen(pStr)<<endl;//12

    return;
}
```
注意：一定要记得数组名并不是真正意义上的指针，它的内涵要比指针丰富的多。但是当数组名当做参数传递给函数后，其失去原来的含义，变作普通的指针。

另外要注意sizeof不是函数，只是操作符。

 

## 42.如何避免“野指针”

1. 指针变量声明时没有被初始化。解决办法：指针声明时初始化，可以是具体的地址值，也可让它指向NULL。

2. 指针p 被 free或者delete之后，没有置为NULL。解决办法：指针指向的内存空间被释放后指针应该指向NULL。

3. 指针操作超越了变量的作用范围。解决办法：在变量的作用域结束前释放掉变量的地址空间并且让指针指向NULL。

注意：“野指针”的解决方法也是编程规范的基本原则，平时使用指针时一定要避免产生“野指针”，在使用指针前一定要检验指针的合法性。

 

## 43.常引用有什么作用
常引用的引入主要是为了避免使用变量的引用时，在不知情的情况下改变变量的值。常引用主要用于定义一个普通变量的只读属性的别名、作为函数的传入形参，避免实参在调用函数中被意外的改变。

说明：很多情况下，需要用常引用做形参，被引用对象等效于常对象，不能在函数中改变实参的值，这样的好处是有较高的易读性和较小的出错率。

```c++
voidmain(void) {
       int ival = 58;
       void refFun(const int& xval);
       refFun(ival);
       cout << ival << endl; //不加const会返回59,加const会报错!

       return;
}

voidrefFun(const int& xval) {
       xval = xval +1; //l-value specifies constobject[报错]
}
```

## 45.简述strcpy、sprintf与memcpy的区别

1. 操作对象不同，strcpy的两个操作对象均为字符串，sprintf的操作源对象可以是多种数据类型，目的操作对象是字符串，memcpy 的两个对象就是两个任意可操作的内存地址，并不限于何种数据类型。

2. 执行效率不同，memcpy最高，strcpy次之，sprintf的效率最低。

3. 实现功能不同，strcpy主要实现字符串变量间的拷贝，sprintf主要实现其他数据类型格式到字符串的转化，memcpy主要是内存块间的拷贝。

说明：strcpy、sprintf与memcpy都可以实现拷贝的功能，但是针对的对象不同，根据实际需求，来选择合适的函数实现拷贝功能。

 
## 46.用C编写一个死循环程序
```c
while(1) { }
```
说明：很多种途径都可实现同一种功能，但是不同的方法时间和空间占用度不同，特别是对于嵌入式软件，处理器速度比较慢，存储空间较小，所以时间和空间优势是选择各种方法的首要考虑条件。

 

## 49.构造函数能否为虚函数
构造函数不能是虚函数。而且不能在构造函数中调用虚函数，因为那样实际执行的是父类的对应函数，因为自己还没有构造好。

析构函数可以是虚函数，而且，在一个复杂类结构中，这往往是必须的。析构函数也可以是纯虚函数，但纯虚析构函数必须有定义体，因为析构函数的调用是在子类中隐含的。

说明：虚函数的动态绑定特性是实现重载的关键技术，动态绑定根据实际的调用情况查询相应类的虚函数表，调用相应的虚函数。

```c++
class Base {
public:
    // virtual Base(){} //会报错：'inline' isthe only legal storage class for constructors

    virtual ~Base(){}
};
 

int main() {
       Base objB;
       cout << endl;
       return 0;
}
```


## 50.谈谈你对面向对象的认识
面向对象可以理解成对待每一个问题，都是首先要确定这个问题由几个部分组成，而每一个部分其实就是一个对象。然后再分别设计这些对象，最后得到整个程序。传统的程序设计多是基于功能的思想来进行考虑和设计的，而面向对象的程序设计则是基于对象的角度来考虑问题。这样做能够使得程序更加的简洁清晰。

说明：编程中接触最多的“面向对象编程技术”仅仅是面向对象技术中的一个组成部分。发挥面向对象技术的优势是一个综合的技术问题，不仅需要面向对象的分析，设计和编程技术，而且需要借助必要的建模和开发工具。

个人认为：可以从项目开发的角度（实践）或面向对象的三大特性（继承、封装、多态）三点入手谈认识。