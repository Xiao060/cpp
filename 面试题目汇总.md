# C/C++方向面试题汇总

## C/C++基础

---

### 描述 C++ 程序的内存由哪几个部分组成，每个区域分别有什么作用和特点

![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202309051546758.png)

1. 栈区：最顶层是栈区，函数入栈就是在这个区域，函数入栈表示要去这片空间中创建一些变量(函数栈空间)

2. **<mark>堆区</mark>**：通过 `malloc` 或者 `new` 创建的内容就在堆区

3. **<mark>全局静态区</mark>**：全局变量、静态变量, *命名空间中的变量* 一 **读写**

4. 文字常量区：字符串常量(文字常量)一 **只读**

5. 程序代码区：函数体的二进制代码 一 **只读**

---

### C++内存分为哪几块？有什么作用？

[见上一题](#描述-C++-程序的内存由哪几个部分组成，每个区域分别有什么作用和特点)

---

### 什么时候分配内存会产生内存碎片？

---

### 负数的编码方式是什么？简述一下它的原理

### 浮点数的编码方式是什么？简述一下它的原理

---

### 可执行程序是如何生成的？

![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/20230716113139.png)

1. 预处理 Preprocessing (<mark>.i</mark>)

    - **`#include`**  -------------头文件包含 (把头文件中的内容复制到指令所在的位置)
    - **`#define N 5`**  -----------宏定义 (简单的文本替换)
    - **`#define FOO(x) (1 + (x) * (x))`**  -------------宏函数(文本替换: 用“实参”替换“形参”)
        - 宏函数注意事项:
            - 括号紧贴名称
            - 参数用括号括起来
            - 整个表达式也应该括起来
        - 宏函数优点
            - 避免函数调用的开销
            - 不限制参数类型, 提供宏编程能力
        - 宏函数应用场景
            - 替换简短的, 反复调用的函数

2. 编译 Compilation (<mark>.s</mark>)

    把预处理后的文件 翻译成 <mark>汇编代码</mark>

3. 汇编 Assembly (<mark>.o</mark>)

    把编译后的汇编代码 翻译成 <mark>机器代码</mark>

4. 链接 Linking (<mark>.out/.exe</mark>)

    把目标文件 与 库文件 链接到一起生成 <mark>可执行</mark>程序

    1. 静态链接 ----> **静态库** (<mark>.a</mark>)

        代码从其所在的 静态库 中拷贝到最终的可执行程序中, 在该程序被执行时, 这些代码会被装入到该进程的虚拟地址空间中

        1. 静态库对函数的链接是在 **链接阶段** 完成的
        2. 程序在运行时, 与静态库再无瓜葛, 移植方便
        3. 浪费空间, 每一个进程中都有静态库的一个副本
        4. 对程序的更新,部署,发布不友好(需要所有用户重新下载安装新的可执行程序)

    2. 动态链接 ----> **动态库** (<mark>.so</mark>)

        代码被放到动态链接库或共享对象的某个目标文件中,链接程序只是在最终的可执行程序中记录了共享对象的名字等一些信息。在程序执行时,动态链接库 的全部内容会被映射到运行时相应进行的虚拟地址的空间。

        1. 动态库对函数的链接是在 **运行时** 完成的
        2. 动态库可以在进程之间共享 (共享库)
        3. 对程序的更新, 部署, 发布友好 (只要更新动态库就好了)
        4. 程序在运行时, 依赖动态库, 不方便移植

补充: 编译命令
    `gcc -E ...` 激活预处理, 生成预处理后的文件 (<mark>.i</mark>)
    `gcc -S ...` 激活预处理和编译, 生成汇编代码 (<mark>.s</mark>)
    `gcc -c ...` 激活预处理、编译和汇编, 生成目标文件 (<mark>.o</mark>)
    `gcc ...` 执行所有阶段,生成可执行程序

---

### 静态库 与 动态库 的生成

1. 静态库

``` shell
# 1. 生成目标文件
gcc -c add.c
gcc -c sub.c
gcc -c mul.c
gcc -c div.c

# 2. 把目标文件打包成静态库, 库的名字为algs
ar crsv libalgs.a add.o sub.o mul.o div.o

# 3. 将生成的静态库移动到/usr/lib目录下
mv libalgs.a /usr/lib
```

2. 动态库

``` shell
# 1. 生成目标文件,需要加上-fpic选项
$ gcc -c add.c -fpic
$ gcc -c sub.c -fpic
$ gcc -c mul.c -fpic
$ gcc -c div.c -fpic

# 2. 把目标文件打包成动态库
$ gcc -shared add.o sub.o mul.o div.o -o libalgs.so

# 3. 将生成的动态库移动到/usr/lib目录下
$ mv libalgs.so /usr/lib
```

---

### 可执行程序是如何变成进程的？

1. 加载 Loading (装入)

    加载器读取可执行文件及其依赖库等,生成进程映像加载到内存。

2. 执行

    CPU 根据二进制指令执行程序。

---

### C 语言 与 C++ 编译的区别

![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202311172232962.png)

1. C++ 为了满足函数重载,  会对函数名进行 **名字改编**(name mangling), 即当函数名称相同时，会根据参数的类型、顺序、个数进行改编; 可以通过 `nm xxx.o` 查看各函数改编后的名称

2. C 语言不会对 函数名进行改编

3. 若在 C++ 中调用 C 函数, 则不会对 C 函数进行 名字改编

---

### 在 C++ 中如何调用 C 函数？

1. 若 C 中函数在 C++ 中不存在 同名函数, 则可以直接导入头文件, 并进行调用

2. 若 C++ 中存在同名函数 且 参数顺序/类型/个数 相同, 则采用 方式1 会直接调用 C++ 的函数

3. 方式2 解决: 在 C++ 文件中 使用 **extern "C"** 修饰调用的函数声明, 则 C++ 文件链接该函数时会选择 C 文件进行链接(即禁止链接名字改编的二进制文件), 从而能够顺利调用 C 函数

```c++
// C 函数头文件
#include "myCCode.h"

extern "C" {
    // C 函数声明
    void myCFunction();  
}

int main() {
    // 调用嵌入的 C 函数
    myCFunction();  
    return 0;
}
```

---

### 在 C 中如何调用 C++ 函数？

1. 将c++相关函数封装为静态库或动态库 (因为调用库函数时编译器并不知道里面执行的是什么语言)

2. 对外提供遵循 类C语言规约的接口函数

```c++
// 1. 提供 C 接口
// printNum.h
#ifdef __cplusplus
extern "C" {
#endif

void printNum(int a);

#ifdef __cplusplus
}
#endif


// 2. 实现函数
// printNum.cc
#include <iostream>
#include "printNum.h"
using namespace std;
void printNum(int a)
{
    cout << << "num is " << a << endl;
}

// 3. 将 printNum.cc 封装为 静态库/动态库

// 4. 在 C 中调用 C++ 函数
// main.c
#include "printNum.h"
printNum(5);
```

---

### 请描述几种常见的 C/C++ 的缺陷和陷阱？

---

### 重写, 重载, 重定义这三者有什么区别？

1. 重载(overload)

    发生在同一个作用域中, 函数名称相同, 而参数列表不同 (即类型、顺序、个数不同)

2. 重定义/隐藏(oversee)

    1. 发生在基类派生类之间, **函数名称相同**, 可以作用于基类虚函数, 也可以作用于基类的非虚函数;

    2. 但是作用于基类非虚函数时不会触发多态

3. 重写/覆盖(override)

    1. 发生在基类派生类之间, 基类与派生类中同时定义相同的虚函数(**函数名/参数/返回值**)

    2. 只能作用于基类的虚函数

    3. 覆盖的是虚函数表中的入口地址, 并不是覆盖函数本身

---

### 说一说 strcpy、sprintf 与 memcpy 这三个函数的不同之处

---

### strlen 和 sizeof 区

---

### 二维数组是什么，函数指针是什么？

---

### 简述值传递、指针传递（地址传递）的区别

---

### C++中const关键字的作用？

1. 修饰变量
    1. 即声明常量, 表示其值不能被修改
    2. 相较于宏常量, 可进行类型检查, 节省内存空间, 提高效率

    若修饰的变量为类的数据成员, 则
    1. C++11 之前 只能在初始化列表中初始化, C++11 支持在声明时初始化
    2. 成员变量只在某个对象的生存周期内是常量, 对于整个类而言是可变的, 因为类可以创建多个对象, 不同类的 const 成员变量的值可以不同, 故此种情况下更推荐 在初始化列表中初始化

2. 修饰函数参数
    表示参数在函数内部不会被修改

3. 修饰成员函数
    1. 表示该函数不能修改任何类型的成员变量 (**mutable**修饰的变量除外)
    2. 不能调用非 const 成员函数, 因为非 const 成员函数可能会修改成员变量

4. 修饰函数返回值

### const常量 和 宏定义常量 有什么区别

1. 发生的时机不同
    C语言中的宏定义常量发生时机是**预处理**阶段，const 常量是在**编译**时

2. 是否有类型检查
    1. 宏定义就是简单地进行了字符串的替换，没有类型检查
    2. const 常量本质是变量，有类型检查。(所以C++中会更倾向于使用 const 常量，更安全)

---

### C++中static关键字的作用？

---

### C 与 C++ 的 struct 区别

1. C 中 struct 是 用户自定义数据类型;
    C++ 中 struct 是 抽象数据类型

2. C 中 struct 是一些 变量的集合体, 不能定义成员函数, 不能设置访问权限;
    C++ 中 struct 与类一样, 除了变量还可以定义成员函数, 可以设置访问权限, 默认访问权限为 public

3. C 中 struct 定义的自定义数据类型, 在定义该类型的变量时, 需要加上 struct 关键字, 例如: `struct A var`;
    C++ 中, 不用加该关键字, 例如: `A var`;

---

### C++ 中 class 和 struct 的异同？

1. 相同点
    1. struct 和 class 都可以自定义数据类型, 也支持继承操作

2. 不同点
    1. struct 中默认的访问权限是 public, 默认的继承方式也是 public;
        class 中默认的访问权限是 private, 默认的继承方式也是 private
        继承方式取决于派生类的默认继承级别。
    2. class 可以用于定义模板参数,struct 不能用于定义模板参数。

---


### C++中类型转换有哪几种？简述一下它们之间的区别

隐式转换/C风格类型转换 (略)

1. `static_cast` 静态类型转换

   `static_cast<目标类型>(转换的对象)`

    1. <mark>编译时</mark> 执行转换
    2. 常用于 **基本数据类型** 之间的转换
    3. 还用于 基类与派生类之间的 **上行转换**, 即 派生类指针/引用 转换为 基类指针/引用
    4. 好处
        - 阻止不合法的转换
        - 方便查找 `grep static_cast * -rn`

2. `const_cast`

    1. 不能用于去掉变量的常量性
    2. 只能用于去除 指针 或 引用 的常量性, 即 将const指针转化为非const指针 或 将const引用转化为非const引用

3. `dynamic_cast` 动态类型转换

    1. **运行时** 进行类型转换
    2. 主要用于 基类与派生类 之间的 <mark>**下行转换**</mark>, 即 基类指针/引用 转换为 派生类指针/引用
    3. 会检查转换的有效性，如果无法转换则返回空指针（对于指针转换）或抛出 std::bad_cast 异常（对于引用转换）

4. `reinterpret_cast` 重新解释转换

    1. 比较底层的转换方式，它将一个指针或引用转换为完全不相关的类型
    2. 绕过了类型系统的检查, 比较危险，需要谨慎使用

---

### C++中 函数指针 和 指针函数 的区别

---

### RAII

---

### C++中有哪些智能指针，它们有什么异同？

定义于头文件 <memory> 中, 其中 `auto_ptr` 属于 C++98, `unique_ptr / shared_ptr / weak_ptr` 属于 C++11

1. `std::auto_ptr` (C++98)

    代码层面存在 bug, 即允许拷贝构造, 但是会发生**所有权的转移**

    ```c++
    auto_ptr<int> ap(new int(10));

    // 将 ap 托管的堆空间 new int(10) 转接给了ap2, 然后将 ap 的 数据成员的指针置空
    // 再对 *ap.get(), 会发生 bug
    auto_ptr<int> ap2(ap);
    ```

2. `std::unique_ptr`

    1. **<mark>独享所有权</mark>** 的智能指针
    2. <mark>不允许 拷贝/赋值</mark> ------> 对象语义
    3. 具备 移动语义 (移动复制/赋值)
    4. 可以作为容器元素  
        将右值转递到容器中, 调用 移动复制  
        不能传左值, 因为 拷贝构造 delete
    5. 删除器 (模板参数中声明)

        ```c++
        // 删除器, operator() 内默认 delete ptr / delete [] ptr
        struct FILECloser {
            void operator()(FILE* ptr) const {
                if (ptr) {
                    fclose(ptr):
                }
            }
        }     

        unique_ptr<FILE, FILECloser> up(fopen(..., ...));
        ```

3. `std::shared_ptr`

    1. **共享所有权** 的智能指针 ----> 通过引用计数表明资源被几个指针共享, 计数减为 0 时, 自动释放内存空间
    2. 可以 复制 / 赋值 -------> 值语义
    3. 支持 移动复制 / 赋值
    4. 可以作为 容器元素  
        既可以传左值, 也可以传右值
    5. <mark>循环引用( **重要** )</mark>  
        存在内存泄漏  
        解决方案: 使用 **弱引用** 智能指针, 不会增加引用计数
        ![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202309221613008.png)
        ![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202309221633067.png)

    6. 删除器 (构造函数中声明)

        ```c++
        // 删除器, operator() 内默认 delete ptr / delete [] ptr
        struct FILECloser {
            void operator()(FILE* ptr) const {
                if (ptr) {
                    fclose(ptr):
                }
            }
        }     

        // 删除器位于 构造函数中, 左右值均可
        // 1. 此处 fc 不能加 括号
        FILECloser fc;
        shared_ptr<FILE> sp(fopen(xxx, xxx)i, fc);
        // 2.  
        shared_ptr<FILE> sp(fopen(xxx, xxx)i, FILECloser());
        ```

4. `std::weak_ptr`

    1. **弱引用** 智能指针, 不会使 引用计数 ++
    2. 不能直接托管关联的堆空间 (不能直接传递一个 **裸指针** 进行构造)
    3. 不能 解引用 / 箭头
    4. 判断资源是否以回收
        1. `use_count`
        2. `expired()`
        3. `lock()`

    ```c++
    shared_ptr sp(new int(10));
    weak_ptr<int> wp;
    wp = sp;

    // 获取引用计数
    sp.use_count();
    wp.use_count();

    // 检查对象是否已经销毁, 返回 bool
    wp.expired();

    // 将 weak_ptr 提升为 shared_ptr; sp2 存在则未被销毁
    shared_ptr<int> sp2 = wp.lock();
    ```

---

### C++中的智能指针？三种指针解决的问题以及区别？

[见上一题](#C++中有哪些智能指针，它们有什么异同？)

---

### shared_ptr使用的注意事项？

1. `shared_ptr` 特有问题

    **循环引用** 导致内存泄漏, 可以使用 `weak_ptr` 解决

2. 智能指针通用问题

    使用了不同的智能指针托管同一片堆空间  

---

### weak_ptr 如何解决 shared_ptr 的循环引用问题？

1. `shared_ptr` 是强引用的智能指针, 会使引用计数进行累加; 但是 `weak_ptr` 是 **弱引用** 的智能指针, 不会使引用计数进行累加

2. 因此将资源内部的 智能指针改为 `weak_ptr`, 则循环引用的两个资源的引用计数并不会增加, 还是 1, 当 `shared_ptr` 销毁时资源引用计数变为 0, 便会自动释放, 不会产生内存泄漏

---

### 假设有一个指针，如何做到多次使用，一次释放？

---

### void*的大小是多少？

---

### 简述一下 malloc / free 的实现原理。为何 free(p) 的时候，只需要传递堆空间的地址就可以了?



---

### malloc 申请内存后，怎么保证一定申请到了呢？你会申请完了后直接使用这片内存吗？

---

### new/delete 与 malloc/free 的异同

1. `malloc/free` 是库函数, `new/delete` 是表达式，不是库函数(后两者也不是函数的写法)

2. `new` 表达式最终的返回值是 相应类型的指针 (**自带类型**) `int* p=new int(1)`
   `malloc`  返回值类型是 void*, 还需要进行相应类型的 强制转换

3. `malloc`  申请空间时不会进行初始化，获取到的空间中可能存在 **脏数据**：
   `new` 表达式申请空间时，可以显式地初始化(给参数)，也可以隐式地初始化(不给参数)

4. `malloc` 的参数是 字节数，new 表达式不需要传递字节数，会根据相应类型自动获取空间。
   `new int(x)` 这样的表达式中，类型后面的参数代表的是初始化的值，如果不给出，就会初始化为该类型的默认值

---

### delete 与 delete []

1. `delete` 和 `delete []` 都用于释放动态分配的内存

2. `delete` 用于释放使用 `new` 运算符分配的 **单个对象** 的内存;
    它会调用对象的析构函数，并释放对象占用的内存;
    如果试图使用 `delete` 释放指向数组的指针，行为将是未定义的

3. `delete []` 用于释放使用 `new []` 运算符分配的 **数组对象** 的内存;
    会调用数组中每个元素的析构函数, 并释放整个数组占用的内存

---

### 指针 和 引用 的区别/联系

1. 联系:
    1. 引用和指针都是用来 **间接** 访问变量
    2. 引用的底层是使用指针完成的, 可以把引用看成一个 受限制 的指针

2. 区别：
    1. 引用不能单独存在，但是指针可以单独存在(野指针问题)
    2. 引用必须初始化，指针可以不初始化：
    3. 引用一经绑定便不能修改绑定，但是指针可以随意修改指向，非常灵活(灵活意味着强大，也意味着容易出错一引用的设计初衷就是希望程序员少用指针)
    4. 引用的地址即变量本身的地址，筒单理解为引用不额外占据内存;
        而指针在内存中占据的空间是存储地址所需要的字节数

---

### 引用作为函数返回时为什么不能返回局部变量？

### extern"C"的用法

### 内联函数和宏定义的区别

---

### 静态变量什么时候初始化

### 动态编译与静态编译

---

### 拷贝构造函数的调用时机

1. 当使用一个已经存在的对象 初始化 另一个同类型的新对象时
2. 当函数参数(实参和形参)的类型都是对象，形参与实参结合时(实参初始化形参)------ **按值传递对象**, 可以使用引用解决
3. 当函数的返回值是对象，执行 return 语句时(编译器有**优化**) -----> 返回的实际是新对象的引用 ???
   `-fno-elide-constructors` 编译时取消优化
   为了避免这次多余的复制，可以使用 引用 作为函数的返回值, 但是要注意引用所绑定的对象的声明周期要比函数更长(static)

---

### inline函数的使用？缺点是什么？

### 为什么拷贝构造函数必须传引用不能传值？

### 类中静态函数占用内存么

### 构造函数初始化和列表初始化的区别

---

### 动态多态（虚函数机制）被激活的条件

1. 基类中要 定义虚函数

2. 派生类中要 **重写** 虚函数 (覆盖的是虚函数表中的地址信息)

3. 要创建 派生类对象

4. **基类指针** 指向派生类对象 (**基类引用** 绑定派生类对象)

5. 通过基类指针(引用) 调用虚函数  
    but 通过 派生类对象 直接调用虚函数 不会触发动态多态, 只发生隐藏

    ```c++
    derived::display();             // 派生类函数
    derived.Base::display();        // 基类函数
    ```

---

### 虚函数的底层实现

![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202309191111520.png)

1. 虚函数的底层实现是通过虚函数表实现;  

2. 基类 中定义 虚函数时, 内存结构中 在该对象的起始位置会存在一个 <mark>**vfptr**(虚函数指针)</mark>, 指向 <mark>虚函数表(虚表)</mark>, 虚表中记录的是 <mark>虚函数的入口地址</mark>

3. 派生类 中重新定义 该函数时(**<mark>函数名/参数/返回值 均相同</mark>**), 发生 <mark>覆盖(override)</mark>, 即覆盖了虚表中虚函数的入口地址  

    此时派生类中的 该函数 即使不加 `virtual` 也是虚函数;  
    在 函数体前 加 `override` 可以确保是函数体的覆盖, 避免函数名写错没有覆盖的问题

4. 当使用 基类指针 指向 派生类对象时, 能够操纵的只有 基类部分(包含 vfptr);
    当使用指针调用 该函数时, 会通过 vfptr 去 虚表 查找

---

### 虚函数表里存放的内容是什么时候写进去的

编译阶段

---

### 虚函数表的作用和存储的地址

1. 作用
    实现多态 见 [虚函数底层实现](#虚函数的底层实现)

2. 位置  
    1. 编译完成时, 虚表应该已经存在;
    2. 在使用的过程中, 虚函数表不应该被修改掉 (如果能修改, 将会找不到对应的虚函数), 故应该存在 **只读段** , 具体位置不同厂家有不同实现

---

### 类指针初始化为空指针后调用成员函数会出问题吗?

---

### 动态指针的判空

---

### 三合成原则

1. **拷贝构造/赋值/析构函数**, 如果手动定义其中的一个, 另外两个也需要手动定义

---

### 为什么析构函数一般写成虚函数

1. 若 基类析构不为虚函数, 则 在 堆上创建派生类对象 并 使用 基类指针 指向时, 最后 `delete xxx` 时, 只会调用 基类的析构函数, 会导致 派生类堆上的数据成员 发生 **内存泄漏**

2. `delete 基类指针;` 此处不会导致 堆上的 派生类对象本身 泄露, 因为 `operator delete` 接收的参数是 `void*` 类型, 回收时会自动推算出需要回收多少字节

3. 基类的 析构函数 设置成了虚函数, 则派生类的析构函数自动覆盖, 不再要求同名

---

### 虚函数的限制

1. <mark>构造函数</mark> 不能设置为虚函数

    构造函数的作用是创建对象, 完成数据的初始化, 而虚函数机制被激活的条件之一就是要先创建对象, 有了对象才能表现出动态多态, 如果将构造函数设为虚函数, 那此时构造未执行完, 对象还没创建出来, 存在矛盾

2. <mark>静态成员函数</mark> 不能设置为虚函数  

    虚函数实际调用: `this -> vfptr -> vtable -> virtual function`  
    but 静态成员函数没有 this 指针, 无法访问到 vfptr

3. <mark>内联函数</mark> 不能设置为虚函数  

    本质 字符串替换, **编译期间**完成, but 编译期间无法展示多态机制, 效果冲突;  
    若同时存在, inline 失效

4. <mark>普通函数</mark> 不能设置为虚函数  
    虚函数要解决的是对象多态的问题, 与普通函数无关

---

### 构造函数可以设置成虚函数吗，为什么？

构造函数的作用是创建对象, 完成数据的初始化, 而虚函数机制被激活的条件之一就是要先创建对象, 有了对象才能表现出动态多态, 如果将构造函数设为虚函数, 那此时构造未执行完, 对象还没创建出来, 存在矛盾

---

### new和malloc之间有什么区别？new申请内存空间的时候为什么不需要类型转化，底层做了些什么事情呢？（new的作用:实例化一个对象。申请内存空间，然后调用相关的构造函数）

### 虚函数和纯虚函数的区别

### STL 中vector删除其中的元素，迭代器如何变化？为什么是两倍扩容？释放空间？

### map、set是怎么实现的，红黑树是怎么能够同时实现这两种容器？ 为什么使用红黑树？

### 模板和实现可不可以不写在一个文件里面？为什么？

### 请简述你了解及使用过的C++11的新特性（提示：如 类型推导、智能指针、lambda匿名函数等）

### 说一说你了解的关于lambda函数的全部知识

### 分别写出在 if 语句的条件中，如何判断 bool a, int a, float a, char *a 是否为“零”

### 以int变量为对象，设计一个类，给出所有成员函数的声明(类似格式的声明只需要写一个)

### 请解释32位/64位系统具体指的是什么长度，对系统有何影响？

### 简述系统物理内存与虚拟内存之间的联系与区别

### 简述你熟悉的编译器的不同的优化级别，以及编译器优化一些基本的思想

### 函数 bool less(float x, float y) { return \*(int \*)&x < \*(int \*)&y; } 是否能正确计算float的大小关系，为何？对应了c++的那种类型转换？

### 有一个 char*p={"abcdefg...z"} 的字符串，这个字符串强转成int型指针，再进行自增运算，求该值

### 谈一下模板 template

### 定义函数时，缺省函数的返回值类型，则函数的返回值类型为

A.float     B.int       C.char      D.void

### 要实现动态连编，必须使用（）调用虚函数？

A.类名      B.派生类指针        C.对象名       D.基类指针

## 面向对象

---

### 面向过程 和 面向对象 的区别？

---

### 面向对象的三大特性有哪些？

1. 封装
    封装是将数据和操作捆绑在一起, 形成一个单个实体, 即类
    通过封装对外部隐藏了实现细节, 这样可以实现数据的 **安全性** 和 **可维护性**，同时提供了对数据的访问控制

2. 继承
    1. 继承是一种通过已有类创建新类的机制
    2. 通过继承，新创建的类(派生类)可以继承现有类(基类)的属性和方法, 并且可以在此基础上进行扩展或修改
    3. 继承提供了代码重用的机制，可以减少重复编写相似功能的代码, 并且支持建立类之间的层次关系
    4. 但是当父类中的成员变量、 成员函数或者类本身被 `final` 关键字修饰时, 修饰的类不能继承, 修饰的成员不能重写或修改

3. 多态
    1. 多态是指相同的接口(方法) 可以在不同的对象上具有不同的实现
    2. 允许使用基类的指针或引用来调用派生类的方法, 在运行时根据对象的实际类型来确定调用的函数
    3. 多态性提高了代码的 **灵活性** 和 **可扩展性**, 使得可以通过统一的接口处理不同类型的对象

---

### 什么是多态？多态分为哪几种，多态的应用场景有哪些？

多态是指相同的接口(方法) 可以在不同的对象上具有不同的实现

1. 静态多态
    1. 即 **编译时多态**, 即 在编译时就确定了要调用的方法, 也就是我们说的 函数重载 (overload)
    2. 函数重载 允许在同一个作用域内定义多个 函数名称相同 但 参数列表(类型/顺序/个数)不同的 函数
    3. 编译器在编译时会根据调用的参数列表选择对应的函数
    4. 因为在编译时就确定了需要调用的函数, 所以效率高, 但是灵活性差
    5. 函数重载 是通过 **名字改编** 实现的

2. 动态多态
    1. 即 **运行时多态**, 也叫做 **子类型多态** 也就是我们平常说的多态;
    2. 基类中定义了虚函数
    3. 派生类继承基类, 并对基类中的虚函数进行 **重写**(override)
    4. 创建派生类对象
    5. 使用基类指针指向派生类对象 或 使用基类引用绑定派生类对象, 并通过 基类指针/引用 调用虚函数
    6. 会在运行时根据 指针实际指向 或 引用实际绑定 的对象来确定要调用的函数
    7. 需要通过 **虚表** 完成

3. 参数多态
    1. 即 **函数模板**, 也即泛型编程
    2. 函数模板允许定义通用的函数, 该函数可以接受不同的参数
    3. 编译器进行编译时可以根据参数类型生成对应的 函数实例

---

### 动态多态的实现过程，静态多态的实现过程

[见 上一题](#什么是多态？多态分为哪几种，多态的应用场景有哪些？)

---

### C++的多态如何实现

---

### 空类里有什么函数？

### A继承B、C两个空类，对A进行强转成B、C，地址空间有什么变化呢？

### public/priavate 继承的关系

### 公有继承 和 私有继承 的应用场景？

### 重载 和 覆盖 的使用？

### 基类和派生类的 构造函数 和 析构函数 的执行顺序？

1. 构造函数

    1. 先执行 基类 的 构造函数
    2. 再执行 成员子对象 的构造函数
    3. 最后执行 派生类 的构造函数

    补充:
    1. 先调用派生类构造函数, 然后在派生类构造函数的初始化列表中会 调用基类构造函数;
        故 从调用顺序上来看 是先调用 派生类构造函数 再调用基类构造函数, 但是 从实际构造顺序上来看, 先构造基类部分, 再构造派生类部分
        故 可以认为 是先执行的 基类构造函数, 再执行的派生类构造函数
    2. 派生类的构造函数若没有显式调用基类的构造函数, 则创建派生类对象时会自动调用 无参构造; 若基类无 无参构造, 则派生类创建失败
    3. 当派生类对象调用基类构造时, 希望使用非默认的基类构造函数, 必须显式地在初始化列表中写出

2. 析构函数

    1. 先执行 派生类对象 的析构函数

    2. 执行完之后执行 成员子对象 的析构函数

    3. 最后执行 基类子对象 的析构函数  

        ![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202309181130840.png)

---

### string 底层实现方式

1. 深拷贝
2. 写时复制
3. 短字符串优化(SSO)

---

### 谈谈深拷贝和浅拷贝，以及如何实现？

---

### string 的赋值操作是深拷贝还是浅拷贝？

---

### string 的 SSO 模式

短字符串优化 (Short String Optimization)

1. 概述  
字符串的长度小于等于15个字节时, buffer直接存放整个字符串;  
当字符串长度大于15个字节时, buffer存放的是一个指针, 指向堆空间的区域;  
**注意:** 对象地址 指向低地址, 内容地址 指向高地址
![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202309151635349.png)

2. 当在栈上创建字符串时
    1. len <= 15, str内容分布在栈上;
    2. len > 15, str内容分布在堆上;  

---

### 什么时候重载 赋值运算符 与 复制拷贝函数？

当对象的数据成员申请了 **堆上** 的空间

---

### 什么地方需要用到拷贝构造函数？

### virtual()=0 是什么意思？

### 虚函数和虚继承是怎么实现？

### 如果我有一块地址空间，我怎么在这个地址空间内调用构造函数？

### sizeof(A) 是多少？

``` c++
class A {
    int a;
    short b;
    double c;
    virtual void fun() {}
    static int d;
};
```

## STL

### STL包括哪些内容？

---

### vector底层实现

1. 由 3 个指针构成
2. `_start` 指向当前数组中第一个元素存放的位置
3. `_finish` 指向当前数组中最后一个元素存放的下一个位置
4. `_end_of_storage` 指向当前容器存放的最后一个元素的下一个位置
5. vector 中的元素存在 堆上
    ![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/image-20230908175603277.png)

---

### vector 和 deque 的区别？

### vector 和 list 的本质区别？

### vector、list在添加删除的效率方面有什么不同？

### 释放vector的内存的处理方式

### vector迭代器失效的情况有哪些？

### map 和 unordermap 的区别

### stl 中的 unordered_map 和 unordered_set 有什么区别呢？

### 自己实现 unordered_map 的话，你会考虑到什么问题呢？

### clear 和 erase 的区别？

### 迭代器失效问题

### swap函数的作用？

### 简述一下STL容器相关知识、特性等？

### stl 当中vector、list、map在内存中的数据结构有什么区别？

### erase的返回值

## Linux

### 说说 Linux 中常用的命令？

1. ls：列出目录中的文件和子目录。
2. cd：改变当前工作目录。
3. pwd：显示当前工作目录的路径。
4. mkdir：创建一个新的目录。
5. touch
6. rm：删除文件或目录。
7. cp：复制文件或目录。
8. mv：移动文件或目录，也可用于重命名文件或目录。
9. cat：查看文件内容。
10. tail:
11. head:
12. echo:
13. grep：在文件中搜索指定的模式。
14. find：在文件系统中查找文件或目录。
15. chmod：修改文件或目录的权限。
16. tar：创建或提取 tar 归档文件。
17. gzip：压缩文件。
18. unzip：解压缩文件。
19. kill：终止运行中的进程。
20. ifconfig：查看和配置网络接口信息。
21. ping：测试与另一台计算机的连通性。
22. ssh：通过安全的远程登录协议连接到远程主机。
23. scp：通过安全的远程拷贝协议在本地主机和远程主机之间复制文件。
24. alias
25. su
26. sudo
27. useradd
28. usermod
29. userdel

30. ps：显示当前运行进程的快照。
31. top：实时显示系统资源使用情况和进程信息。
32. netstat
33. tcpdump

### 创建软连接的命令是什么？

`ln -s <target> <link_name>`

### /proc文件夹下放的是什么？

### Linux下有哪些文件类型？

### Linux查看内存、磁盘、端口、进程、线程命令有哪些？

### gdb的基本使用

### 是否在linux系统下用过gdb或者别的调试工具，对于gdb来说，用过哪些功能？

### gdb 用法如果堆栈的信息不准，怎么办（不能运行，不能修改代码），可能是是哪里出了问题

### 如果某个模块运行过程中突然崩溃，但是崩溃的几率不大，如何定位并解决这个问题？

### 如果是在一个循环内出现问题，使用gdb调试需要等待很长时间，应该怎么处理？

### 内存泄漏怎么检查，怎么避免？

### 什么是 coredump 文件？怎么调试？

### 什么时候用静态库和什么时候用动态库，两者有何区别？

### 零拷贝技术有哪些？

### mmap的应用场景有哪些？

### linux文件系统读入文件的过程

## 进程和线程

### 线程和进程区别？

### 中断和异常的区别

### 进程和线程的本质区别

### 多进程和多线程的区别是什么？换句话说，什么时候该用多线程，什么时候该用多进程？

### 进程间通信方式？

### 线程间通信的方式？

### Linux程序运行找不到动态库.so文件的三种解决办法

### Linux进程同步的机制

### 什么是同步、异步？什么是阻塞、非阻塞？

### 进程间通信的方式有哪些？

### 进程的六种状态

### 什么是孤儿进程？什么是僵尸进程？怎么避免僵尸进程？

### 结束进程的方式有哪些？

### 什么是会话(session)？

### 守护进程与后台进程的区别

### 写时拷贝

### 自旋锁

### 谈一下对多线程的理解，如生产者 - 消费者问题

### 什么是死锁？死锁产生的条件？怎么解决死锁问题？

### 信号量处理耗费多长时间，信号量同步会有什么问题

### 登录 shell 进程是如何启动的？shell 是如何调用系统调用的？

### sleep()调用后进程有哪些过程，在sleep()的过程中进程占用CPU了吗？

### 线程池有什么好处？

### 讲一下线程池？

### 什么是线程安全？

### 多线程间共享数据，用什么方式来保存它们的安全性

### 什么是线程安全函数，工作中如何保证线程安全

### 可重入函数是什么意思，为什么一定是线程安全的

## 网络

### 简述七层模型和四层模式

### 请描述一下从输入URL到显示页面的全过程

### 简述一下 socket 编程的流程

### write 阻塞的原因有哪些？

### 多路复用：select, poll, epoll 的区别？epoll 的底层是如何实现的？

### epoll边沿触发具体实现方式

### LT和ET的区别，应用场景？

### 说说同步、异步、阻塞、非阻塞

### 调用send函数发送数据不全怎么办？

### 1G的文件从A机器发送到B机器，怎么发？(写代码实现)

### 什么是 TCP 的"粘包"问题？怎么解决？

### tcp和udp的区别？

### tcp三次握手建立连接的过程？三次握手过程通信双方各自的状态？

### tcp四次挥手的过程？四次挥手过程中通信双方各自的状态？

### 简述一下 tcp 的超时机制

### tcp通信过程的状态是如何变化的

### 从实用的角度来讲，三次握手的真实目的？（从硬件的角度来看，每一次握手的意义？）

### 网络的七层模型？每一层的协议？

### 为什么TIME_WAIT状态需要经过2MSL才能返回到CLOSE状态

### TCP 利用滑动窗口实现流量控制的机制？

### 如何根据IP获取对方的MAC地址？ARP协议了解一下

### Proactor和Reactor的区别和特点

### 怎样加快大文件在网络中传输，根据滑动窗口与拥塞控制考虑

### http和https的区别？

### HTTP有哪些常用方法？HTTP端口号？

### SSH基于TCP还是UDP？端口号？

### 讲一下WLAN？

### 网卡的中断、几级缓存、网络方面遇到瓶颈怎么解决？

### 什么时候会产生time_wait，如果系统出现大规模time_wait怎么处理？

## 数据结构与算法

## 链表

### 红黑树的思想，红黑树的特点，红黑树和平衡二叉树的区别？红黑树的查找为什么是O(logn)?

### 负载均衡算法

### 海量数据Top K问题

### 有损压缩和无损压缩算法

### 三个有序的序列，查找公共的部分

### 合并两个有序数组或链表

### 实现一个栈，实现O(1)时间复杂度求栈的最小元素

### 100G的文本，每行80k还是80字符，提示用多个机器，多进程，多线程，求出重复最多的行。一内存8G，计算每个机器大概分多少？能读取100G的文本吗？找重复率前十的文本

### 两数之和(leetocde第一题)

### 将奇数放于数组前面，偶数放于后面

### 设计一个可以求最大值的栈

### 余弦相似度算法

### 如何判断单链表是否有环？

### 反转单链表

### 怎么判断单链表是否相交？

### B树和B+树的特点以及应用场景？

### hashmap实现的思路和方法(类似于STL中的unordered_map)

### Hash表处理冲突的方式有什么？

### 说一下什么是一致性哈希

### 最短编辑距离问题

### LRU 实现原理

### 邻接矩阵是什么？

### 贪心算法是什么，怎么保证最后的结果是最优的？

## 树

### 二叉树的深度优先遍历：先序，中序，后序

### 二叉树层次遍历

### 二叉树镜像反转

### 假设数组为{3,5,7,4,6,2,1},构建一个二叉排序树,并输出排序结果

    a)代码实现
    b)简述思路

## 排序

### 请实现冒泡排序

### 请实现归并排序

### 请实现快速排序

### 快速排序算法思想？

### 快排和堆排的应用场景

### 简述你所知道的std::sort实现方法

### 写一个排序函数，时间复杂度不大于O(nlogn)，如果有多线程时该排序算法可如何优化，或者无法多线程优化的原因

## 查找

### 设计一个目标字符串查询系统，输入一个目标字符串，找出磁盘上40亿个字符串中和目标字符串完全匹配的字符串，可以对40亿个字符串（数据量> 100GB，服务器可用内存为8GB）进行预处理

    a. 如果目标是尽可能快的完成字符串搜索工作，应该如何设计。
    b. 如果不仅需要找到目标字符串还需要返回按字典序排在该字符串后面的字符串数量，又该如何设计呢？

### 实现二分查找算法

## Leetcode

    8，21，39，86，127，146

## 其它题目

### 有一个包含4个字节的数 a，将它的每个字节相加，结果对 b 取模，如果结果小于c则称之为有效数，统计输入的数字中包含有效数的个数

    输入：c b  10个数   例：3 4 256 257 258 259 260 261 262 263 264 265
    输出：有效数的个数   例：4

### 如果一个字符串符合“辅音+元音(aeiou)+辅音(除了r)+e"的格式，则称它为有效字符串。输入一组字符串，用空格区分，如果单词中不包含非字母元素，则将单词翻转，统计翻转后的每个单词中包含有效字符串的个数，输出其中的最大值

    输入：一组字符串    例：!maxe a ekekac
    输出：最大值        例：2
    分析：!maxe a ekekac翻转后为!maxe a cakeke。cakeke中有两个有效字符串cake和keke，故输出2。

### solo 和 koko 是两兄弟，两人分一堆积木，每块积木都有自己的重量，弟弟koko要求积木的重量必须相等，否则就会哭（按照koko的标准），可是koko只会将数字转化为二进制后相加，而且总会忘记进位（每次都会忘记）。solo应该如何分积木，才能使自己得到的积木重量尽可能大，如果不能则输出-1？

    输入：积木个数 每个积木的重量    例：3 3 5 6
    输出：solo能拿到积木的最大重量   例：11

### 给出字符串含 数字（0-9）和 ？ 例如（ ???1234?256??????3251? ）其中 ? 可以为任何数，求字符串转成数后 %13 = 5 的情况数量

    给的要求:字符串长度达到 10^5 ，数字前段可以为0

### 已知某栅格三角网上三个顶点A(x,y,z),B(x,y,z),C(x,y,z),求三角网范围内任意点的高程z

    a)代码实现
    b)简述思路

### 实现全排列

## 数据库

## MySQL

### 数据库事务是什么？

### 数据库事务有哪些特性？

### 事务的隔离级别有多少种，分别是什么？

### 不可重复读和幻读区别是什么？可以举个例子吗

### 什么是聚合索引 ？什么是非聚合索引

### 数据库索引怎么用，适合什么场景，什么时候索引失效?

### 如何对索引进行优化？

### 创建索引一定能加快检索速度吗，为什么？

### 为什么MySQL索引要使用B+树，而不是B树或者红黑树？

### 你知道哪些数据库结构优化的手段

### B树和B+树区别

### 怎么判断一个查询是否是高效率的？

### 如何优化查询语句？

### MySQL的约束有哪些？

### inner join, left join, right join, outer join 的区别？

### mysql 如何合并两个表?

### 共享锁与独占锁

### 乐观锁和悲观锁

### 了解过存储过程吗？

### 了解过数据库视图吗

## Redis

### Redis常见数据结构以及使用场景分别是什么？

### Redis持久化机制可以说一说吗？

### 了解Redis的线程模型吗？可以大致说说吗？

### 有没有读过Redis源码

### C++中的Map也是一种缓存型数据结构，为什么不用Map，而选择Redis做缓存？

### Redis是如何部署的？

### 简述一下主从复制和哨兵模式的原理？

### 解释一下Redis缓存雪崩，缓存穿透，缓存预热？

### redis的有序集合底层实现是什么？如果让你实现，你会怎么实现？

### redis失效时应该怎么处理，如果让你设计你方案，你会怎么设计？

## 设计模式

### 为什么用组合而不要用继承？

### 单例模式的构造函数？单例模式的创建过程？如何保证线程安全？

### 手写单例模式

### 如何使用单例模式，有什么注意事项？

### 如果使用单例模式时创建了多个对象，如何定位问题？

### 请简述一下适配器模式？

### 实现一个简单的观察者模式

    a)代码实现

    b)简述思路

### 使用过的设计模式，应用场景，如何应用？阐述业务背景和应用的方式

## 项目

## 网盘项目

### 客户端发消息给服务器，服务器端是如何解析的？

### 多个用户上传同一份文件该如何处理？

### 秒传如何实现？

### 断点续传如何实现？

### 讲一下虚拟文件目录

### 前后端的通信方式知道哪几种？

### 当你上传文件或更改文件时，如果出现问题，网络中断了；会不会导致数据库和文件对不上，怎么解决的？

### 如何做token验证？

### 网盘项目的网络通信方式

### 有考虑过多线程同时上传一个文件的问题吗？

### md5的算法是自己实现的吗？

### 文件如何和用户绑定？

### 连接使用的是长连接还是短链接？

### 长连接socket的参数是怎么设置的？

### 项目为什么要进行文件去重？

### 线程池是如何实现的？

### 线程池在项目当中是怎么用的，分别有哪些线程，它们是怎么分工的？

### 线程池中的线程数目是否会随并发量动态增加？

### 如何确定线程池中线程的状态？

## 搜索引擎项目

### 一个网页的信息是通过什么形式存储的？

### Simhash是什么，怎么使用的，用什么存储的？

### 介绍一下倒排索引，余弦相似度算法

### 任务队列是怎么实现的，阻塞还是非阻塞？

### 负载均衡怎么做的？

### 什么是最短编辑距离，给你几个例子说说他们的最短编辑距离

### 双缓存轮换是怎么做到的，为什么不使用单缓存加锁？

### LRU算法的原理

### 为什么使用LRU算法，还可以选用什么算法？

### 如何加快搜索速度？

### 缓存和数据库如何实现同步操作

### 项目当中的任务队列具体会有哪些任务？

### 搜索引擎项目用了几个进程几个线程池

## Http 项目

### 介绍一下这个workflow编程范式是什么，怎么用的，以及这个框架能对项目起到什么作用？

### 有没有用什么二进制通信协议？

## 开放性问题

### 离职原因

### 大学学过的和软件开发相关的课程？

### 互联网以后的发展

### 有没有看过开源代码和较深的数据结构？

### 给一个尺子，算一栋楼的高度

### 1000支试管，只有一支有毒，怎么用最少的小白鼠检测出有毒？

### 最佩服的人

### 最大的挫折

### 有没有研究新技术

### 毕业论文是什么？你对毕业论文的理解(这个论文的方向为什么吸引你)？

### 你有什么想问的？

### C++了解到什么程度？

### 你之前工作小组怎么构成的？都干了多久？

### 你之前公司是做什么业务的？

### 之前工作累吗？工作时间之类的问题？

### 你过去的工资怎么构成的？

### 了解过我们公司吗？

### 了解QT客户端开发吗？

### 是否对OpenGL有了解？

### 工作压力主要来自哪儿？

### 工作过程中最难忘的一件事儿？

### 未来的职业规划？

### 进入公司后，一年的规划

### 项目需求怎么来的？

### 项目怎么展开的？

### 代码怎么测试的？

### 测试用例自己写吗？

### 多久做一个项目？

### 修复bug的过程？讲一个具体修复过的bug？怎么发现的bug？

### 如果某个模块运行过程中内存增长速度过快，应该怎么处理？

### 处理过的难度最高或挑战性最大的问题？

### 有没有什么学习计划？使用这种学习计划多长时间了，会不会有完不成的情况？

### 旁边有人不停打扰，怎么办？

### 你在找工作时更看中什么？

### 接受加班么？

### 期望薪资多少呢？

### 对这个行业有什么看法

### C++ primer中令你印象最深刻的是什么？

### 是否会用UML?

### 上一家公司的总体规模

### 上一家公司是什么样的开发，是敏捷式还是瀑布式还是别的类型的开发模式

### 如何验证自己所写代码的质量？

### 在以前的工作当中是否参与到某几款软件或者系统的设计工作/软件设计？

## 项目相关

### 介绍一下你的项目

### 整个项目做了多长时间？项目多少个人？

### 你的项目瓶颈在哪？怎么优化的？性能提升了多少？

### 使用过什么测试性能的工具？

### 项目中遇到的最大的问题是什么？

### 你们系统的性能如何？系统挂掉了怎么办？系统挂掉后，会不会有断流出现？

### 项目组人数，担任的角色，工作的流程，如何提交给测试？

### 如果需要在已有项目上新增功能，需要考虑哪些问题？

### 项目有没有做过压测，怎么做的？

### 常用的云服务有用过吗？它的原理是？

### 私有云有没有用到集群
