# STL  

(标准模板库, Standard Template Library)

## 容器

### 序列式容器

#### 初始化

|     | vector | deque | list |
| --- | :---: | :---: | :---: |
| 无参 | √ | √ | √ |
| count 个 value | √ | √ | √ |
| 迭代器范围 | √ | √ | √ |
| 拷贝/移动 构造 | √ | √ | √ |
| 初始化列表 (大括号) | √ | √ | √ |

#### 遍历

|     | vector | deque | list |
| --- | :---: | :---: | :---: |
| 下标 | √ | √ | <mark>×</mark> |
| 迭代器 | √ | √ | √ |
| 增强 for 循环 (依托 迭代器) | √ | √ | √ |

#### 基本操作

|     |     | vector | deque | list |
| --- | --- | :---: | :---: | :---: |
|     | push_front() | <mark>×</mark> | √ | √ |
|     | pop_front() | <mark>×</mark> | √ | √ |
|     |  |  |  |  |
| 就地插入, 避免拷贝 | emplace_back() | √ | √ | √ |
| 有可能拷贝 | push_back() | √ | √ | √ |
|     | pop_back() | √ | √ | √ |
|     |  |  |  |  |
|     | insert() | √ | √ | √ |
|     |  |  |  |  |
|     | erase() | √ | √ | √ |
|     |  |  |  |  |
|     | resize() | √ | √ | √ |
|     |  |  |  |  |
|     | swap() | √ | √ | √ |
|     |  |  |  |  |
|     | clear() | √ | √ | √ |
|     | capacity() | √ | <mark>×</mark> | <mark>×</mark> |
| 回收未使用空间 | shrink_to_fit() | √ | √ | <mark>×</mark> |
| 预留空间, 防止频繁扩容 | reserve() | √ | √ | √ |
| 获取第一个元素的地址 | data() | √ | √ | √ |
|     |  |  |  |  |
|     | reverse() |  |  | √ |
|     | sort() |  |  | √ |
| 移除连续重复元素 | unique() |  |  | √ |
|     | merge() |  |  | √ |
|     | () |  |  | √ |

1. 为何 vector 不支持在头部进行插入与删除呢?  

    vector中的元素是连续的, 如果在头部进行插入与删除的时间复杂度比较高 O(n)

2. `insert()`

    1. 插入方式

        1. 找一个位置插入 1 个元素

        2. 找一个位置插入 count 个 value

        3. 找一个位置插入 迭代器范围的元素

        4. 找一个位置插入 大括号范围的元素

    2. deque 插入存在 前半部分 与 后半部分 的概念

    3. vector 迭代器失效 (<mark>重要</mark>)

        概念: 底层发生扩容现象, 而迭代器还指向老的空间, 使用 老的迭代器 去操作 新的空间  

        解决方案: vector 每次插入前重新置位(获取) 迭代器

3. `erase()`: 删除元素

    删除元素后 迭代器 不要往后挪, 否则会漏掉某些元素

    ```c++
    for (auto it = x.begin(); it != it.end(); ) {
        if (*it == 7) {
            x.erase(it)
        } else {
            ++it;
        }
    }
    ```

#### vector

![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202309260956926.png)  

![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202309261024551.png)

结论: 在 vector 中随机访问的时候，可以使用下标，也可以使用 `at` 函数，但是下标是没有范围检查的，所以有可能出现越界的风险，但是 `at` 函数是有范围检查的，就没有越界的风险。

```c++
// 获取 vector 第一个元素地址
vector<int> numbet = {...};

&number[0];
&*number.begin();
int* pdata = number.data();
```

#### deque

![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202309261033477.png)  

![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202309261057206.png)

![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202309261104426.png)

特点:

1. 逻辑上连续, 物理上不连续

2. 片段之间是依靠中控器数组进行控制的

#### list

1. `sort()`

    ```c++
    // 1. 从小到大
    x.sort();
    x.sort(std::less<int>());

    // 2. 从大到小
    x.sort(std::greater<int>());
    
    // 3. 自定义 排序方式
    struct CompareList {
        bool operator()(const int& lhs, const int& rhs) const {
            return lhs < rhs;
        }
    }
    x.sort(CompareList);
    ```

### 关联式容器  

set/map

### 无序关联式容器  

unordered_set/unordered_map

## 迭代器

广义/泛型指针, 容器 与 算法之间的桥梁

## 适配器

1. 容器的适配器: stack/queue/priority_queue(优先级队列)

2. 迭代器的适配器

3. 函数适配器

## 算法

## 函数对象(仿函数)

定制化操作, 例: 删除器

## 空间配置器

进行空间的申请与释放
