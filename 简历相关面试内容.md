# 简历相关面试内容

## C++ 流程控制

1. 选择
    `if...else if...else`
2. 循环
    `while...` / `do...while` / `for...`
3. 跳转
    `break` / `continue` / `goto` / `return`

## 指针问题

1. 野指针
    野指针是一个未被初始化的指针;

2. 悬空指针
    悬空指针指 指针指向的内存空间已被释放或不再有效;

3. 解决方案
    1. 定义指针时便进行初始化, 无法确定值 可以先初始化为 nullptr
    2. 访问 指针指向的值时, 先判断指针是否为空
    3. 删除 指针指向的空间后将指针置为 nullptr
    4. 使用 智能指针

## 指针 和 引用 的区别/联系

1. 联系:
    1. 引用和指针都是用来 **间接** 访问变量
    2. 引用的底层是使用指针完成的, 可以把引用看成一个 受限制 的指针

2. 区别：
    1. 引用不能单独存在，但是指针可以单独存在(野指针问题)
    2. 引用必须初始化，指针可以不初始化：
    3. 引用一经绑定便不能修改绑定，但是指针可以随意修改指向，非常灵活(灵活意味着强大，也意味着容易出错一引用的设计初衷就是希望程序员少用指针)
    4. 引用的地址即变量本身的地址，筒单理解为引用不额外占据内存;
        而指针在内存中占据的空间是存储地址所需要的字节数

## 面向对象与面向过程区别

## 面向对象特点

1. 封装
    将数据和方法 捆绑在一起, 形成一个类;
    该类会提供对数据的访问控制, 但是对外会隐藏类内部实现细节, 由此实现数据的 **安全性** 和 **可维护性**;
    类的设计原则中, 开闭原则要求 **对拓展开放, 对修改关闭**, 需要借助 抽象类 来实现

2. 继承
    1. 通过已有类创建新类即为继承
    2. 通过继承, 派生类 可以继承 基类 的属性和方法, 并且可以在此基础上进行**扩展或修改**, 如 重写虚函数
    3. 可以减少代码重复, 提高代码的复用率
    4. 但是当基类中的 **虚函数** 或 **类本身** 被 `final` 关键字修饰, 则修饰的类不能继承, 修饰的虚函数不能重写

3. 多态
    1. 多态是指相同的接口(方法) 可以在不同的对象上具有不同的实现
    2. 允许使用基类的指针或引用来调用派生类的方法, 在运行时根据对象的实际类型来确定调用的函数
    3. 多态性提高了代码的 **灵活性** 和 **可扩展性**, 使得可以通过统一的接口处理不同类型的对象

    分类: 静态多态/动态多态/参数多态

## 泛型编程

1. 即 **函数/类模板**
2. 函数模板允许定义通用的函数, 该函数可以接受不同的参数
3. 编译器进行**编译**时可以根据参数类型生成对应的 函数实例

## (动态)多态实现原理

1. 基类中若定义了虚函数, 则在基类函数入口地址处会存在一个**虚函数指针**, 该指针指向**虚函数表**, 虚函数表中储存虚函数的入口地址;
2. 当派生类继承了基类, 并且重写虚函数, 则派生类的虚函数入口地址会覆盖虚函数表中的基类的虚函数入口地址;
3. 当使用基类指针指向派生类对象 或者 使用基类引用绑定派生类对象时 会根据虚函数指针去寻找虚表, 继而找到虚函数入口地址;
4. 而此时找到的其实是派生类对象的虚函数

## 重载/重定义/重写 这三者有什么区别？

1. 重载(overload)
    发生在同一个作用域中, 函数名称相同, 而参数列表不同 (即类型、顺序、个数不同)

2. 重定义/隐藏(oversee)
    1. 发生在基类派生类之间, **函数名称相同**, 可以作用于基类虚函数, 也可以作用于基类的非虚函数;

    2. 但是作用于基类非虚函数时不会触发多态

3. 重写/覆盖(override)

    1. 发生在基类派生类之间, 基类与派生类中同时定义相同的虚函数(**函数名/参数/返回值**)

    2. 只能作用于基类的虚函数

    3. 覆盖的是虚函数表中的入口地址, 并不是覆盖函数本身

## C++中有哪些智能指针，它们有什么异同？

定义于头文件 <memory> 中, 其中 `auto_ptr` 属于 C++98, `unique_ptr / shared_ptr / weak_ptr` 属于 C++11

1. `std::auto_ptr` (C++98)

    代码层面存在 bug, 即允许拷贝构造, 但是会发生**所有权的转移**

    ```c++
    auto_ptr<int> ap(new int(10));

    // 将 ap 托管的堆空间 new int(10) 转接给了ap2, 然后将 ap 的 数据成员的指针置空
    // 再对 *ap.get(), 会发生 bug
    auto_ptr<int> ap2(ap);
    ```

2. `std::unique_ptr`

    1. **<mark>独享所有权</mark>** 的智能指针
    2. <mark>不允许 拷贝/赋值</mark> ------> 对象语义
    3. 具备 移动语义 (移动复制/赋值)
    4. 可以作为容器元素  
        将右值转递到容器中, 调用 移动复制  
        不能传左值, 因为 拷贝构造 delete
    5. 删除器 (模板参数中声明)

        ```c++
        // 删除器, operator() 内默认 delete ptr / delete [] ptr
        struct FILECloser {
            void operator()(FILE* ptr) const {
                if (ptr) {
                    fclose(ptr):
                }
            }
        }     

        unique_ptr<FILE, FILECloser> up(fopen(..., ...));
        ```

3. `std::shared_ptr`

    1. **共享所有权** 的智能指针 ----> 通过引用计数表明资源被几个指针共享, 计数减为 0 时, 自动释放内存空间
    2. 可以 复制 / 赋值 -------> 值语义
    3. 支持 移动复制 / 赋值
    4. 可以作为 容器元素  
        既可以传左值, 也可以传右值
    5. <mark>循环引用( **重要** )</mark>  
        存在内存泄漏  
        解决方案: 使用 **弱引用** 智能指针, 不会增加引用计数
        ![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202309221613008.png)
        ![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202309221633067.png)

    6. 删除器 (构造函数中声明)

        ```c++
        // 删除器, operator() 内默认 delete ptr / delete [] ptr
        struct FILECloser {
            void operator()(FILE* ptr) const {
                if (ptr) {
                    fclose(ptr):
                }
            }
        }     

        // 删除器位于 构造函数中, 左右值均可
        // 1. 此处 fc 不能加 括号
        FILECloser fc;
        shared_ptr<FILE> sp(fopen(xxx, xxx)i, fc);
        // 2.  
        shared_ptr<FILE> sp(fopen(xxx, xxx)i, FILECloser());
        ```

4. `std::weak_ptr`

    1. **弱引用** 智能指针, 不会使 引用计数 ++
    2. 不能直接托管关联的堆空间 (不能直接传递一个 **裸指针** 进行构造)
    3. 不能 解引用 / 箭头
    4. 判断资源是否以回收
        1. `use_count`
        2. `expired()`
        3. `lock()`

    ```c++
    shared_ptr sp(new int(10));
    weak_ptr<int> wp;
    wp = sp;

    // 获取引用计数
    sp.use_count();
    wp.use_count();

    // 检查对象是否已经销毁, 返回 bool
    wp.expired();

    // 将 weak_ptr 提升为 shared_ptr; sp2 存在则未被销毁
    shared_ptr<int> sp2 = wp.lock();
    ```

---

### shared_ptr使用的注意事项？

1. `shared_ptr` 特有问题

    **循环引用** 导致内存泄漏, 可以使用 `weak_ptr` 解决

2. 智能指针通用问题

    使用了不同的智能指针托管同一片堆空间  

---

### weak_ptr 如何解决 shared_ptr 的循环引用问题？

1. `shared_ptr` 是强引用的智能指针, 会使引用计数进行累加; 但是 `weak_ptr` 是 **弱引用** 的智能指针, 不会使引用计数进行累加

2. 因此将资源内部的 智能指针改为 `weak_ptr`, 则循环引用的两个资源的引用计数并不会增加, 还是 1, 当 `shared_ptr` 销毁时资源引用计数变为 0, 便会自动释放, 不会产生内存泄漏

### lambda 函数

1. 格式
    `[]()->xx{}`
    1. `[]` 为捕获列表, 捕获可以按值捕获/按引用捕获/混合捕获;
        按值捕获 `=` / 按引用捕获 `&` / 混合捕获 `[=, xx, xx]` `[&, xx, xx]`
    2. `()` 参数列表
    3. `xx` 为返回值类型, 可省略;
    4. `{}` 为函数体

2. 提供了一种便捷的方式来编写简洁、**内联** 的函数代码

### std::function

头文件<functional>

1. `std::function` 是一个函数包装器, 可以包装可调用实体, 如普通函数/函数对象/lamda表达式等

### 移动语义

1. 移动语义是指将一块内存单元从一个对象转移到另一个对象

2. 分类
    ![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202311232236103.png)
    表达式分为 泛左值 + 右值;
    泛左值又分为 左值 + 将亡值, 具名;
    右值又分为 将亡值 + 纯右值, 可移动;
    即 左值:具名不可移动; 将亡值:具名可移动; 纯右值:不具名可移动;

3. 泛左值来源
    1. 左值经 `std:move` 转换
    2. 将纯右值作为返回值时, C++17编译器会将其优化为将亡值

### STL包括哪些内容？

1. 容器
2. 迭代器
3. 算法
4. 适配器
5. 函数对象
6. 空间配置器

### vector 底层实现

1. 由 3 个指针构成
2. `_start` 指向当前数组中第一个元素存放的位置
3. `_finish` 指向当前数组中最后一个元素存放的下一个位置
4. `_end_of_storage` 指向当前容器存放的最后一个元素的下一个位置
5. vector 中的元素存在 堆上
    ![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/image-20230908175603277.png)

## vector 迭代器失效的情况有哪些？

1. vector 迭代器失效
    1. 概念: 底层发生扩容现象, 而迭代器还指向老的空间, 使用 老的迭代器 去操作 新的空间  
    2. 解决方案: vector 每次插入前重新置位(获取) 迭代器
    3. insert 扩容策略
        size() = m, capacity() = n, 待插入的元素的个数 t
        1. t < n - m; 此时就不会扩容
        2. n - m < t < m; 会按照 2*m 进行扩容
        3. n - m < t, m < t; 会按照 m+t 进行扩容

        push_back 每次插入元素的个数都是固定的 1, 所以按照 两倍 进行扩容肯定容器是足够的;  
        但是 insert 进行插入元素的时候, 元素的个数是不一定的, 所以不能按照某个固定值的两倍进行扩容.

2. 解决方案
    1. 进行修改操作后, 重新获取新的迭代器
    2. 对于vector, 可以使用索引代替迭代器进行访问
    3. 如果需要在循环中进行修改操作, 并且需要同时使用迭代器, 可以考虑使用 **迭代器的返回值** 来更新迭代器
        如 insert()、erase() 会返回指向被插入或删除元素位置的迭代器

### 释放 vector 的内存的处理方式

1. `clear()`
    将容器中的元素清空, 并且保留容器的容量不变; 可以释放元素占用的内存，保留容量可以避免重新分配内存的开销, 以备后续再次存储元素使用

2. `shrink_to_fit()`
    可以将容器容量减少至当前大小, 释放多余内存

3. 析构函数

### clear 和 erase 的区别？

1. `clear()` 用于清空容器中的所有元素, 将容器恢复为空, 不释放内存
    `erase()` 用于删除容器中的一个或多个元素, 可以通过指定位置或迭代器来删除, 会使得后续元素向前移动, 容器大小减少
2. `clear()` 不会使迭代器失效, 而 `erase()` 可能会使迭代器失效
3. `erase()` 返回指向待删除元素下一个元素的迭代器

## deque

1. 特点:
    1. 逻辑上连续, 物理上不连续
    2. 片段之间是依靠中控器数组进行控制的
        ![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202309261033477.png)  
        ![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202309261057206.png)
        ![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202309261104426.png)
        ![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202311241024104.png)

### map 和 unordered_map 的区别

1. 底层实现
    map 底层实现为红黑树, unordered_map 底层实现为 hash

2. 有序性
    map 是一个有序容器, 它根据**键值**进行排序;
    unordered_map 是一个无序容器

3. 查找操作
    1. map 查找的时间复杂度为 O(log n)的元素数量。且提供额外操作, 如 `lower_bound()` 和 `upper_bound()`
        `lower_bound` 返回首个 >= 给定值的迭代器
        `upper_bound` 返回首个 > 给定值的迭代器
        ![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202311241101045.png)
    2. unordered_map 查找的时间复杂度为 O(1)

4. 迭代器稳定性：

    map 的迭代器在插入和删除操作后仍然有效, 不会失效
    unordered_map 的插入和删除操作可能会导致哈希表的重新哈希, 从而使得迭代器失效

### 空间配置器的底层实现

特点：将空间的申请与对象的构建以及空间回收与对象的销毁严格的分开了

1. 一级空间配置器
    \> 128B
    分配大块内存, `malloc()` / `free`

2. 二级空间配置器
    1. <= 128B

        16 个自由链表 + 内存池

        1. 对于小片空间, 可以防止频繁进行空间申请的问题 (内存碎片问题)

        2. 为了防止频繁在内核态与用户态之间进行切换导致的系统开销

            ![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202310032237118.png)

### string 的底层实现

## 问题汇总

1. 引用到底会不会占用额外的存储空间, 哪怕极小的额外空间
2. 