# 多态

## 概述

1. 概念
    不同对象面对同一指令产生不同行为

2. 分类
    1. 静态多态: 编译时可以确定  
        函数重载 / 运算符重载 / 函数模板 ----> 静态联编
    2. 动态多态: 运行时可以确定  
        虚函数 (virtual)

3. 动态多态(虚函数指针)
    ![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202309191113631.png)

## 虚函数原理

![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202309191111520.png)

1. 基类 中定义 虚函数时, 内存结构中会 存在一个 vfptr(虚函数指针), 指向虚函数表(虚表), 虚表中记录的是虚函数的 入口地址  

2. 派生类 中重定义 该函数时(**函数名/参数/返回值 均相同**), 发生覆盖(override), 即覆盖了虚表中虚函数的入口地址  
    此时派生类中的 该函数 即使不加 `virtual` 也是虚函数;  
    在 函数体前 加 `override` 可以确保是函数体的覆盖, 避免函数名写错没有覆盖的问题

3. 当使用 基类指针 指向 派生类对象时, 能够操纵的只有 基类部分(包含 vfptr); 当使用指针调用 该函数时, 会通过 vfptr 去 虚表 查找

## 动态多态（虚函数机制）被激活的条件

1. 基类中要 定义虚函数
2. 派生类中要 覆盖虚函数 (覆盖的是虚函数表中的地址信息)
3. 要创建 派生类对象
4. 基类 **指针** 指向派生类对象 (基类 **引用** 绑定派生类对象)
5. 通过基类指针(引用) 调用虚函数  
    通过 派生类对象 直接调用虚函数 不会触发动态多态, 只发生隐藏

    ```c++
    derived::display();             // 派生类函数
    derived.Base::display();        // 基类函数
    ```

## virtual关键字的含义 (<mark>面试常考</mark>)

存在、间接、共享

1. 虚函数是 存在的
2. 通过 间接 的方式去访问
3. 通过基类的指针访问到派生类的函数, 基类的指针 共享 了派生类的方法

## 虚函数表

1. 虚函数表存在位置  
    编译完成时, 虚表应该已经存在; 在使用的过程中, 虚函数表不应该被修改掉 (如果能修改, 将会找不到对应的虚函数), 故应该存在 **只读段** , 具体位置不同厂家有不同实现
2. 一个类中虚函数表有几张  
    1. 一个类可以 没有 虚函数表
    2. 可以有 一张 虚函数表 (如果一个类中定义了多个虚函数, 也是把这些虚函数的入口地址存在一张虚函数表中)
    3. 可以有 多张 虚函数表 (如果继承了多个含有虚函数的基类, 就会有多张虚表)

## 虚函数底层实现 (<mark>面试常考</mark>)

1. 虚函数的底层实现是通过虚函数表实现;  
2. 当类中定义了虚函数, 就会在对象的存储开始位置, 多一个虚函数指针;  
3. 该函数指针指向一张虚函数表, 虚函数表中存储的是虚函数入口地址;

## 虚函数的限制

1. 构造函数不能设置为虚函数 (<mark>**面试常考题**</mark>)  
    构造函数的作用是创建对象, 完成数据的初始化, 而虚函数机制被激活的条件之一就是要先创建对象, 有了对象才能表现出动态多态, 如果将构造函数设为虚函数, 那此时构造未执行完, 对象还没创建出来, 存在矛盾

2. 静态成员函数不能设置为虚函数  
    虚函数实际调用: `this -> vfptr -> vtable -> virtual function`  
    but 静态成员函数没有 this 指针, 无法访问到 vfptr

3. 内联函数不能设置为虚函数  
    本质 字符串替换, 编译期间完成, but 编译期间无法展示多态机制, 效果冲突;  
    若同时存在, inline 失效

4. 普通函数不能设置为虚函数  
    虚函数要解决的是对象多态的问题, 与普通函数无关

## 重载 / 隐藏 / 覆盖 辨析 (<mark>**面试重点**</mark>)

1. 重载(overload): 发生在同一个类中, 当函数名称相同时, 函数参数类型、顺序、个数不同

2. 隐藏(oversee): 发生在基类派生类之间, **函数名称相同**

3. 覆盖(override): 发生在基类派生类之间, 基类与派生类中同时定义相同的虚函数(**函数名/参数/返回值**)覆盖的是虚函数表中的入口地址, 并不是覆盖函数本身

## 在 构造 / 析构 函数中访问 虚函数

1. 在 构造/析构 执行过程中, 该函数无法分辨是主动调用还是派生类调用, 即只能看到本层及以上的部分(静态联编)

## 在 普通成员函数中 调用虚函数

![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202309191522083.png)  

编译过程中 this 指针可以发生向上提升

## 纯虚函数

### 特点

1. 纯虚函数只作为接口存在, 没有实现, 它的实现要交给派生类完成

2. 形式： `virtual returntype func(P arams...) = 0;`

3. 定义了纯虚函数的类称为抽象类, 抽象类不能实例化对象  
    抽象类形式2: 定义了 protected 型构造函数的类

4. 当 基类 含有多个 纯虚函数, 且其派生类 未实现完 基类的所有纯虚函数, 那么该 派生类也无法创建对象;  
    可以再往下派生, 直到实现所有纯虚函数都被实现, 便可以创建对象  
    再使用 基类指针 指向 对象

### 解释

1. 派生类B实现了纯虚函数之后，可以创建B类对象，可以定义一个A类指针指向B类对象（基类指针指向派生类对象）可以通过pa指针拿到B的print方法

2. A类中定义纯虚函数，也就是留下了可供使用的接口，但是具体实现由其派生类完成，客户拿到八类的信息，只能知道提供了哪些接口，不能创建A类对象，但是可以用A类指针去调用这些接

```c++
class Figure {
public:
    virtual getName() const  = 0;
    virtual getArea() const = 0;
}

void display(Figure& fig) {
    cout << fig.getName() << " 面积为: " << getArea() << endl;
}

class Rectangle
: public Figure {
public: 
    Rectangle(double length, double width) 
    : _length(length)
    , _width(width) {}

    string getName() const override {
        return "矩形";
    }

    double getArea() const override {
        return _length * _width;
    }

private:
    double _lenght;
    double _width;
};


```

## 补充

1. 编译时常量: 在编译时就能够确定值的常量  
    static 数据成员必须在 类外进行初始化, (不创建对象, 也完成了初始化)  
    整数可以在编译时确定值, 使用 `static const int` 即可  
    浮点数的数值比较复杂, 编译时无法确定, 若想要获取编译时常量 需要使用 `static constexpr double`

2. 运行时常量: 在程序运行时才能确定值的常量
    const 数据成员 在构造函数初始化列表中初始化(也可以声明时直接赋值), 不创建对象, const 数据就没有被初始化, 故 const 数据可以为 编译时常量 也可以为 运行时常量

3. 面向对象设计原则 **开闭原则**  
    对拓展开放, 对修改关闭

## 析构函数需要设为虚函数

1. 若 基类析构不为虚函数, 则 在 堆上创建派生类对象 并 使用 基类指针 指向时, 最后 `delete xxx` 时, 只会调用 基类的析构函数, 会导致 派生类堆上的数据成员 发生泄漏  
2. `delete 基类指针;` 此处不会导致 堆上的 派生类对象本身 泄露, 因为 `operator delete` 接收的参数是 `void*` 类型, 回收时会自动推算出需要回收多少字节
3. 基类的 析构函数 设置成了虚函数, 则派生类的析构函数自动覆盖, 不再要求同名

## 普通继承 与 虚拟继承 区别

1. 虚拟继承  
    1. 解决存储二义性 时 中间层采用的继承方式 `: virtual public xxx`
    2. 中间层除了要存储自身数据外, 还需要在开始位置 存储**虚基指针**, 虚基指针指向 **虚基表**, 虚基表中存放的是 **虚基类对象的偏移信息**
    3. 虚基类 位于 派生类布局的 末尾, 偏移位置由 虚基表 记录  
     ![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202309181525144.png)

## 虚基表的内容

1. 第一条 表示 **该虚基指针** 距离 **所在的子对象** 的首地址的偏移
2. 第二条 表示 **该虚基指针** 距离 **虚基类子对象** 的首地址的偏移

## 带 虚拟继承 的 构造

1. A 普通派生 B/C, D 普通继承 B/C, 则 D 类的构造函数中只需要显示调用 B/C 的构造即可(可能带来二义性)
2. 如果 中间层采用虚拟继承, 底层的构造函数中
    1. 若只写中间层的构造函数, 则默认调用顶层的 无参构造;
    2. 若想调用顶层的有参构造, 需要在底层中显式调用
