# 多态

## 概述

1. 概念
    不同对象面对同一指令产生不同行为

2. 分类
    1. 静态多态: 编译时可以确定  
        函数重载 / 运算符重载 / 函数模板 ----> 静态联编
    2. 动态多态: 运行时可以确定  
        虚函数 (virtual)

3. 动态多态(虚函数指针)
    ![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202309191113631.png)

## 虚函数原理

![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202309191111520.png)

1. 基类 中定义 虚函数时, 内存结构中会 存在一个 vfptr(虚函数指针), 指向虚函数表(虚表), 虚表中记录的是虚函数的 入口地址  

2. 派生类 中重定义 该函数时, 发生覆盖(override), 即覆盖了虚表中虚函数的入口地址  

3. 当使用 基类指针 指向 派生类对象时, 能够操纵的只有 基类部分(包含 vfptr); 当使用指针调用 该函数时, 会通过 vfptr 去 虚表 查找

## 动态多态（虚函数机制）被激活的条件

1. 基类中要 定义虚函数
2. 派生类中要 覆盖虚函数 (覆盖的是虚函数表中的地址信息)
3. 要创建 派生类对象
4. 基类 **指针** 指向派生类对象 (基类 **引用** 绑定派生类对象)
5. 通过基类指针(引用) 调用虚函数

## virtual关键字的含义 (<mark>面试常考</mark>)

存在、间接、共享

1. 虚函数是 存在的
2. 通过 间接 的方式去访问
3. 通过基类的指针访问到派生类的函数, 基类的指针 共享 了派生类的方法

## 虚函数表

1. 虚函数表存在位置  
    编译完成时, 虚表应该已经存在; 在使用的过程中, 虚函数表不应该被修改掉 (如果能修改, 将会找不到对应的虚函数), 故应该存在 **只读段** , 具体位置不同厂家有不同实现
2. 一个类中虚函数表有几张  
    1. 一个类可以 没有 虚函数表
    2. 可以有 一张 虚函数表 (如果一个类中定义了多个虚函数, 也是把这些虚函数的入口地址存在一张虚函数表中)
    3. 可以有 多张 虚函数表 (如果继承了多个含有虚函数的基类, 就会有多张虚表)

## 虚函数底层实现 (<mark>面试常考</mark>)

1. 虚函数的底层实现是通过虚函数表实现;  
2. 当类中定义了虚函数, 就会在对象的存储开始位置, 多一个虚函数指针;  
3. 该函数指针指向一张虚函数表, 虚函数表中存储的是虚函数入口地址;

## 虚函数的限制

1. 构造函数不能设置为虚函数 (<mark>**面试常考题**</mark>)  
    构造函数的作用是创建对象, 完成数据的初始化, 而虚函数机制被激活的条件之一就是要先创建对象, 有了对象才能表现出动态多态, 如果将构造函数设为虚函数, 那此时构造未执行完, 对象还没创建出来, 存在矛盾

2. 静态成员函数不能设置为虚函数  
    虚函数实际调用: `this -> vfptr -> vtable -> virtual function`  
    but 静态成员函数没有 this 指针, 无法访问到 vfptr

3. 内联函数不能设置为虚函数  
    本质 字符串替换, 编译期间完成, but 编译期间无法展示多态机制, 效果冲突;  
    若同时存在, inline 失效

4. 普通函数不能设置为虚函数  
    虚函数要解决的是对象多态的问题, 与普通函数无关
