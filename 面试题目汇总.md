# C/C++方向面试题汇总

## C/C++基础

---

### 描述 C++ 程序的内存由哪几个部分组成，每个区域分别有什么作用和特点

![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202309051546758.png)

1. 栈区：最顶层是栈区，函数入栈就是在这个区域，函数入栈表示要去这片空间中创建一些变量(函数栈空间)

2. **<mark>堆区</mark>**：通过 `malloc` 或者 `new` 创建的内容就在堆区

3. **<mark>全局静态区</mark>**：全局变量、静态变量, *命名空间中的变量* 一 **读写**

4. 文字常量区：字符串常量(文字常量)一 **只读**

5. 程序代码区：函数体的二进制代码 一 **只读**

---

### C++内存分为哪几块？有什么作用？

[见上一题](#描述-C++-程序的内存由哪几个部分组成，每个区域分别有什么作用和特点)

---

### 什么时候分配内存会产生内存碎片？

---

### 负数的编码方式是什么？简述一下它的原理

### 浮点数的编码方式是什么？简述一下它的原理

---

### 可执行程序是如何生成的？

![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/20230716113139.png)

1. 预处理 Preprocessing (<mark>.i</mark>)

    - **`#include`**  -------------头文件包含 (把头文件中的内容复制到指令所在的位置)
    - **`#define N 5`**  -----------宏定义 (简单的文本替换)
    - **`#define FOO(x) (1 + (x) * (x))`**  -------------宏函数(文本替换: 用“实参”替换“形参”)
        - 宏函数注意事项:
            - 括号紧贴名称
            - 参数用括号括起来
            - 整个表达式也应该括起来
        - 宏函数优点
            - 避免函数调用的开销
            - 不限制参数类型, 提供宏编程能力
        - 宏函数应用场景
            - 替换简短的, 反复调用的函数

2. 编译 Compilation (<mark>.s</mark>)

    把预处理后的文件 翻译成 <mark>汇编代码</mark>

3. 汇编 Assembly (<mark>.o</mark>)

    把编译后的汇编代码 翻译成 <mark>机器代码</mark>

4. 链接 Linking (<mark>.out/.exe</mark>)

    把目标文件 与 库文件 链接到一起生成 <mark>可执行</mark>程序

    1. 静态链接 ----> **静态库** (<mark>.a</mark>)

        代码从其所在的 静态库 中拷贝到最终的可执行程序中, 在该程序被执行时, 这些代码会被装入到该进程的虚拟地址空间中

        1. 静态库对函数的链接是在 **链接阶段** 完成的
        2. 程序在运行时, 与静态库再无瓜葛, 移植方便
        3. 浪费空间, 每一个进程中都有静态库的一个副本
        4. 对程序的更新,部署,发布不友好(需要所有用户重新下载安装新的可执行程序)

    2. 动态链接 ----> **动态库** (<mark>.so</mark>)

        代码被放到动态链接库或共享对象的某个目标文件中,链接程序只是在最终的可执行程序中记录了共享对象的名字等一些信息。在程序执行时,动态链接库 的全部内容会被映射到运行时相应进行的虚拟地址的空间。

        1. 动态库对函数的链接是在 **运行时** 完成的
        2. 动态库可以在进程之间共享 (共享库)
        3. 对程序的更新, 部署, 发布友好 (只要更新动态库就好了)
        4. 程序在运行时, 依赖动态库, 不方便移植

补充: 编译命令
    `gcc -E ...` 激活预处理, 生成预处理后的文件 (<mark>.i</mark>)
    `gcc -S ...` 激活预处理和编译, 生成汇编代码 (<mark>.s</mark>)
    `gcc -c ...` 激活预处理、编译和汇编, 生成目标文件 (<mark>.o</mark>)
    `gcc ...` 执行所有阶段,生成可执行程序

---

### 静态库 与 动态库 的生成

1. 静态库

``` shell
# 1. 生成目标文件
gcc -c add.c
gcc -c sub.c
gcc -c mul.c
gcc -c div.c

# 2. 把目标文件打包成静态库, 库的名字为algs
ar crsv libalgs.a add.o sub.o mul.o div.o

# 3. 将生成的静态库移动到/usr/lib目录下
mv libalgs.a /usr/lib
```

2. 动态库

``` shell
# 1. 生成目标文件,需要加上-fpic选项
$ gcc -c add.c -fpic
$ gcc -c sub.c -fpic
$ gcc -c mul.c -fpic
$ gcc -c div.c -fpic

# 2. 把目标文件打包成动态库
$ gcc -shared add.o sub.o mul.o div.o -o libalgs.so

# 3. 将生成的动态库移动到/usr/lib目录下
$ mv libalgs.so /usr/lib
```

---

### 可执行程序是如何变成进程的？

1. 加载 Loading (装入)

    加载器读取可执行文件及其依赖库等,生成进程映像加载到内存。

2. 执行

    CPU 根据二进制指令执行程序。

---

### C 语言 与 C++ 编译的区别

![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202311172232962.png)

1. C++ 为了满足函数重载,  会对函数名进行 **名字改编**(name mangling), 即当函数名称相同时，会根据参数的类型、顺序、个数进行改编; 可以通过 `nm xxx.o` 查看各函数改编后的名称

2. C 语言不会对 函数名进行改编

3. 若在 C++ 中调用 C 函数, 则不会对 C 函数进行 名字改编

---

### 在 C++ 中如何调用 C 函数？

1. 若 C 中函数在 C++ 中不存在 同名函数, 则可以直接导入头文件, 并进行调用

2. 若 C++ 中存在同名函数 且 参数顺序/类型/个数 相同, 则采用 方式1 会直接调用 C++ 的函数

3. 方式2 解决: 在 C++ 文件中 使用 **extern "C"** 修饰调用的函数声明, 则 C++ 文件链接该函数时会选择 C 文件进行链接(即禁止链接名字改编的二进制文件), 从而能够顺利调用 C 函数

```c++
// C 函数头文件
#include "myCCode.h"

extern "C" {
    // C 函数声明
    void myCFunction();  
}

int main() {
    // 调用嵌入的 C 函数
    myCFunction();  
    return 0;
}
```

---

### 在 C 中如何调用 C++ 函数？

1. 将c++相关函数封装为静态库或动态库 (因为调用库函数时编译器并不知道里面执行的是什么语言)

2. 对外提供遵循 类C语言规约的接口函数

```c++
// 1. 提供 C 接口
// printNum.h
#ifdef __cplusplus
extern "C" {
#endif

void printNum(int a);

#ifdef __cplusplus
}
#endif


// 2. 实现函数
// printNum.cc
#include <iostream>
#include "printNum.h"
using namespace std;
void printNum(int a)
{
    cout << << "num is " << a << endl;
}

// 3. 将 printNum.cc 封装为 静态库/动态库

// 4. 在 C 中调用 C++ 函数
// main.c
#include "printNum.h"
printNum(5);
```

---

### 请描述几种常见的 C/C++ 的缺陷和陷阱？

---

### 重写, 重载, 重定义这三者有什么区别？

1. 重载(overload)

    发生在同一个作用域中, 函数名称相同, 而参数列表不同 (即类型、顺序、个数不同)

2. 重定义/隐藏(oversee)

    1. 发生在基类派生类之间, **函数名称相同**, 可以作用于基类虚函数, 也可以作用于基类的非虚函数;

    2. 但是作用于基类非虚函数时不会触发多态

3. 重写/覆盖(override)

    1. 发生在基类派生类之间, 基类与派生类中同时定义相同的虚函数(**函数名/参数/返回值**)

    2. 只能作用于基类的虚函数

    3. 覆盖的是虚函数表中的入口地址, 并不是覆盖函数本身

---

### 重载 和 覆盖 的使用？

---

### 说一说 strcpy、sprintf 与 memcpy 这三个函数的不同之处

---

### strlen 和 sizeof 区

---

### 二维数组是什么，函数指针是什么？

---

### 简述值传递、指针传递（地址传递）的区别

---

### C++中const关键字的作用？

1. 修饰变量
    1. 即声明常量, 表示其值不能被修改
    2. 相较于宏常量, 可进行类型检查, 节省内存空间, 提高效率

    若修饰的变量为类的数据成员, 则
    1. C++11 之前 只能在初始化列表中初始化, C++11 支持在声明时初始化
    2. 成员变量只在某个对象的生存周期内是常量, 对于整个类而言是可变的, 因为类可以创建多个对象, 不同类的 const 成员变量的值可以不同, 故此种情况下更推荐 在初始化列表中初始化

2. 修饰函数参数
    表示参数在函数内部不会被修改

3. 修饰成员函数
    1. 表示该函数不能修改任何类型的成员变量 (**mutable**修饰的变量除外)
    2. 不能调用非 const 成员函数, 因为非 const 成员函数可能会修改成员变量

4. 修饰函数返回值

### const常量 和 宏定义常量 有什么区别

1. 发生的时机不同
    C语言中的宏定义常量发生时机是**预处理**阶段，const 常量是在**编译**时

2. 是否有类型检查
    1. 宏定义就是简单地进行了字符串的替换，没有类型检查
    2. const 常量本质是变量，有类型检查。(所以C++中会更倾向于使用 const 常量，更安全)

---

### C++中static关键字的作用？

---

### C 与 C++ 的 struct 区别

1. C 中 struct 是 用户自定义数据类型;
    C++ 中 struct 是 抽象数据类型

2. C 中 struct 是一些 变量的集合体, 不能定义成员函数, 不能设置访问权限;
    C++ 中 struct 与类一样, 除了变量还可以定义成员函数, 可以设置访问权限, 默认访问权限为 public

3. C 中 struct 定义的自定义数据类型, 在定义该类型的变量时, 需要加上 struct 关键字, 例如: `struct A var`;
    C++ 中, 不用加该关键字, 例如: `A var`;

---

### C++ 中 class 和 struct 的异同？

1. 相同点
    1. struct 和 class 都可以自定义数据类型, 也支持继承操作

2. 不同点
    1. struct 中默认的访问权限是 public, 默认的继承方式也是 public;
        class 中默认的访问权限是 private, 默认的继承方式也是 private
        继承方式取决于派生类的默认继承级别。
    2. class 可以用于定义模板参数,struct 不能用于定义模板参数。

---

### C++中类型转换有哪几种？简述一下它们之间的区别

隐式转换/C风格类型转换 (略)

1. `static_cast` 静态类型转换

   `static_cast<目标类型>(转换的对象)`

    1. <mark>编译时</mark> 执行转换
    2. 常用于 **基本数据类型** 之间的转换
    3. 还用于 基类与派生类之间的 **上行转换**, 即 派生类指针/引用 转换为 基类指针/引用
    4. 好处
        - 阻止不合法的转换
        - 方便查找 `grep static_cast * -rn`

2. `const_cast`

    1. 不能用于去掉变量的常量性
    2. 只能用于去除 指针 或 引用 的常量性, 即 将const指针转化为非const指针 或 将const引用转化为非const引用

3. `dynamic_cast` 动态类型转换

    1. **运行时** 进行类型转换
    2. 主要用于 基类与派生类 之间的 <mark>**下行转换**</mark>, 即 基类指针/引用 转换为 派生类指针/引用
    3. 会检查转换的有效性，如果无法转换则返回空指针（对于指针转换）或抛出 std::bad_cast 异常（对于引用转换）

4. `reinterpret_cast` 重新解释转换

    1. 比较底层的转换方式，它将一个指针或引用转换为完全不相关的类型
    2. 绕过了类型系统的检查, 比较危险，需要谨慎使用

---

### C++中 函数指针 和 指针函数 的区别

---

### RAII

---

### C++中有哪些智能指针，它们有什么异同？

定义于头文件 <memory> 中, 其中 `auto_ptr` 属于 C++98, `unique_ptr / shared_ptr / weak_ptr` 属于 C++11

1. `std::auto_ptr` (C++98)

    代码层面存在 bug, 即允许拷贝构造, 但是会发生**所有权的转移**

    ```c++
    auto_ptr<int> ap(new int(10));

    // 将 ap 托管的堆空间 new int(10) 转接给了ap2, 然后将 ap 的 数据成员的指针置空
    // 再对 *ap.get(), 会发生 bug
    auto_ptr<int> ap2(ap);
    ```

2. `std::unique_ptr`

    1. **<mark>独享所有权</mark>** 的智能指针
    2. <mark>不允许 拷贝/赋值</mark> ------> 对象语义
    3. 具备 移动语义 (移动复制/赋值)
    4. 可以作为容器元素  
        将右值转递到容器中, 调用 移动复制  
        不能传左值, 因为 拷贝构造 delete
    5. 删除器 (模板参数中声明)

        ```c++
        // 删除器, operator() 内默认 delete ptr / delete [] ptr
        struct FILECloser {
            void operator()(FILE* ptr) const {
                if (ptr) {
                    fclose(ptr):
                }
            }
        }     

        unique_ptr<FILE, FILECloser> up(fopen(..., ...));
        ```

3. `std::shared_ptr`

    1. **共享所有权** 的智能指针 ----> 通过引用计数表明资源被几个指针共享, 计数减为 0 时, 自动释放内存空间
    2. 可以 复制 / 赋值 -------> 值语义
    3. 支持 移动复制 / 赋值
    4. 可以作为 容器元素  
        既可以传左值, 也可以传右值
    5. <mark>循环引用( **重要** )</mark>  
        存在内存泄漏  
        解决方案: 使用 **弱引用** 智能指针, 不会增加引用计数
        ![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202309221613008.png)
        ![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202309221633067.png)

    6. 删除器 (构造函数中声明)

        ```c++
        // 删除器, operator() 内默认 delete ptr / delete [] ptr
        struct FILECloser {
            void operator()(FILE* ptr) const {
                if (ptr) {
                    fclose(ptr):
                }
            }
        }     

        // 删除器位于 构造函数中, 左右值均可
        // 1. 此处 fc 不能加 括号
        FILECloser fc;
        shared_ptr<FILE> sp(fopen(xxx, xxx)i, fc);
        // 2.  
        shared_ptr<FILE> sp(fopen(xxx, xxx)i, FILECloser());
        ```

4. `std::weak_ptr`

    1. **弱引用** 智能指针, 不会使 引用计数 ++
    2. 不能直接托管关联的堆空间 (不能直接传递一个 **裸指针** 进行构造)
    3. 不能 解引用 / 箭头
    4. 判断资源是否以回收
        1. `use_count`
        2. `expired()`
        3. `lock()`

    ```c++
    shared_ptr sp(new int(10));
    weak_ptr<int> wp;
    wp = sp;

    // 获取引用计数
    sp.use_count();
    wp.use_count();

    // 检查对象是否已经销毁, 返回 bool
    wp.expired();

    // 将 weak_ptr 提升为 shared_ptr; sp2 存在则未被销毁
    shared_ptr<int> sp2 = wp.lock();
    ```

---

### C++中的智能指针？三种指针解决的问题以及区别？

[见上一题](#C++中有哪些智能指针，它们有什么异同？)

---

### shared_ptr使用的注意事项？

1. `shared_ptr` 特有问题

    **循环引用** 导致内存泄漏, 可以使用 `weak_ptr` 解决

2. 智能指针通用问题

    使用了不同的智能指针托管同一片堆空间  

---

### weak_ptr 如何解决 shared_ptr 的循环引用问题？

1. `shared_ptr` 是强引用的智能指针, 会使引用计数进行累加; 但是 `weak_ptr` 是 **弱引用** 的智能指针, 不会使引用计数进行累加

2. 因此将资源内部的 智能指针改为 `weak_ptr`, 则循环引用的两个资源的引用计数并不会增加, 还是 1, 当 `shared_ptr` 销毁时资源引用计数变为 0, 便会自动释放, 不会产生内存泄漏

---

### 假设有一个指针，如何做到多次使用，一次释放？

---

### void*的大小是多少？

---

### 简述一下 malloc / free 的实现原理。为何 free(p) 的时候，只需要传递堆空间的地址就可以了?



---

### malloc 申请内存后，怎么保证一定申请到了呢？你会申请完了后直接使用这片内存吗？

---

### new/delete 与 malloc/free 的异同

1. `malloc/free` 是库函数, `new/delete` 是表达式，不是库函数(后两者也不是函数的写法)

2. `new` 表达式最终的返回值是 相应类型的指针 (**自带类型**) `int* p=new int(1)`
   `malloc`  返回值类型是 void*, 还需要进行相应类型的 强制转换

3. `malloc`  申请空间时不会进行初始化，获取到的空间中可能存在 **脏数据**：
   `new` 表达式申请空间时，可以显式地初始化(给参数)，也可以隐式地初始化(不给参数)

4. `malloc` 的参数是 字节数，new 表达式不需要传递字节数，会根据相应类型自动获取空间。
   `new int(x)` 这样的表达式中，类型后面的参数代表的是初始化的值，如果不给出，就会初始化为该类型的默认值

---

### delete 与 delete []

1. `delete` 和 `delete []` 都用于释放动态分配的内存

2. `delete` 用于释放使用 `new` 运算符分配的 **单个对象** 的内存;
    它会调用对象的析构函数，并释放对象占用的内存;
    如果试图使用 `delete` 释放指向数组的指针，行为将是未定义的

3. `delete []` 用于释放使用 `new []` 运算符分配的 **数组对象** 的内存;
    会调用数组中每个元素的析构函数, 并释放整个数组占用的内存

---

### 指针 和 引用 的区别/联系

1. 联系:
    1. 引用和指针都是用来 **间接** 访问变量
    2. 引用的底层是使用指针完成的, 可以把引用看成一个 受限制 的指针

2. 区别：
    1. 引用不能单独存在，但是指针可以单独存在(野指针问题)
    2. 引用必须初始化，指针可以不初始化：
    3. 引用一经绑定便不能修改绑定，但是指针可以随意修改指向，非常灵活(灵活意味着强大，也意味着容易出错一引用的设计初衷就是希望程序员少用指针)
    4. 引用的地址即变量本身的地址，筒单理解为引用不额外占据内存;
        而指针在内存中占据的空间是存储地址所需要的字节数

---

### 引用作为函数返回时为什么不能返回局部变量？

### extern"C"的用法

### 内联函数和宏定义的区别

---

### 静态变量什么时候初始化

### 动态编译与静态编译

---

### 拷贝构造函数的调用时机

1. 当使用一个已经存在的对象 初始化 另一个同类型的新对象时
2. 当函数参数(实参和形参)的类型都是对象，形参与实参结合时(实参初始化形参)------ **按值传递对象**, 可以使用引用解决
3. 当函数的返回值是对象，执行 return 语句时(编译器有**优化**) -----> 返回的实际是新对象的引用 ???
   `-fno-elide-constructors` 编译时取消优化
   为了避免这次多余的复制，可以使用 引用 作为函数的返回值, 但是要注意引用所绑定的对象的声明周期要比函数更长(static)

---

### inline函数的使用？缺点是什么？

### 为什么拷贝构造函数必须传引用不能传值？

### 类中静态函数占用内存么

### 构造函数初始化和列表初始化的区别

---

### 动态多态（虚函数机制）被激活的条件

1. 基类中要 定义虚函数

2. 派生类中要 **重写** 虚函数 (覆盖的是虚函数表中的地址信息)

3. 要创建 派生类对象

4. **基类指针** 指向派生类对象 (**基类引用** 绑定派生类对象)

5. 通过基类指针(引用) 调用虚函数  
    but 通过 派生类对象 直接调用虚函数 不会触发动态多态, 只发生隐藏

    ```c++
    derived::display();             // 派生类函数
    derived.Base::display();        // 基类函数
    ```

---

### 虚函数的底层实现

![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202309191111520.png)

1. 虚函数的底层实现是通过虚函数表实现;  

2. 基类 中定义 虚函数时, 内存结构中 在该对象的起始位置会存在一个 <mark>**vfptr**(虚函数指针)</mark>, 指向 <mark>虚函数表(虚表)</mark>, 虚表中记录的是 <mark>虚函数的入口地址</mark>

3. 派生类 中重新定义 该函数时(**<mark>函数名/参数/返回值 均相同</mark>**), 发生 <mark>覆盖(override)</mark>, 即覆盖了虚表中虚函数的入口地址  

    此时派生类中的 该函数 即使不加 `virtual` 也是虚函数;  
    在 函数体前 加 `override` 可以确保是函数体的覆盖, 避免函数名写错没有覆盖的问题

4. 当使用 基类指针 指向 派生类对象时, 能够操纵的只有 基类部分(包含 vfptr);
    当使用指针调用 该函数时, 会通过 vfptr 去 虚表 查找

---

### 虚函数表里存放的内容是什么时候写进去的

编译阶段

---

### 虚函数表的作用和存储的地址

1. 作用
    实现多态 见 [虚函数底层实现](#虚函数的底层实现)

2. 位置  
    1. 编译完成时, 虚表应该已经存在;
    2. 在使用的过程中, 虚函数表不应该被修改掉 (如果能修改, 将会找不到对应的虚函数), 故应该存在 **只读段** , 具体位置不同厂家有不同实现

---

### 类指针初始化为空指针后调用成员函数会出问题吗?

---

### 动态指针的判空

---

### 三合成原则

1. **拷贝构造/赋值/析构函数**, 如果手动定义其中的一个, 另外两个也需要手动定义

---

### 为什么析构函数一般写成虚函数

1. 若 基类析构不为虚函数, 则 在 堆上创建派生类对象 并 使用 基类指针 指向时, 最后 `delete xxx` 时, 只会调用 基类的析构函数, 会导致 派生类堆上的数据成员 发生 **内存泄漏**

2. `delete 基类指针;` 此处不会导致 堆上的 派生类对象本身 泄露, 因为 `operator delete` 接收的参数是 `void*` 类型, 回收时会自动推算出需要回收多少字节

3. 基类的 析构函数 设置成了虚函数, 则派生类的析构函数自动覆盖, 不再要求同名

---

### 虚函数的限制

1. <mark>构造函数</mark> 不能设置为虚函数

    构造函数的作用是创建对象, 完成数据的初始化, 而虚函数机制被激活的条件之一就是要先创建对象, 有了对象才能表现出动态多态, 如果将构造函数设为虚函数, 那此时构造未执行完, 对象还没创建出来, 存在矛盾

2. <mark>静态成员函数</mark> 不能设置为虚函数  

    虚函数实际调用: `this -> vfptr -> vtable -> virtual function`  
    but 静态成员函数没有 this 指针, 无法访问到 vfptr

3. <mark>内联函数</mark> 不能设置为虚函数  

    本质 字符串替换, **编译期间**完成, but 编译期间无法展示多态机制, 效果冲突;  
    若同时存在, inline 失效

4. <mark>普通函数</mark> 不能设置为虚函数  
    虚函数要解决的是对象多态的问题, 与普通函数无关

---

### 构造函数可以设置成虚函数吗，为什么？

构造函数的作用是创建对象, 完成数据的初始化, 而虚函数机制被激活的条件之一就是要先创建对象, 有了对象才能表现出动态多态, 如果将构造函数设为虚函数, 那此时构造未执行完, 对象还没创建出来, 存在矛盾

---

### new和malloc之间有什么区别？new申请内存空间的时候为什么不需要类型转化，底层做了些什么事情呢？（new的作用:实例化一个对象。申请内存空间，然后调用相关的构造函数）

### 虚函数和纯虚函数的区别

### STL 中vector删除其中的元素，迭代器如何变化？为什么是两倍扩容？释放空间？

### map、set是怎么实现的，红黑树是怎么能够同时实现这两种容器？ 为什么使用红黑树？

### 模板和实现可不可以不写在一个文件里面？为什么？

### 请简述你了解及使用过的C++11的新特性（提示：如 类型推导、智能指针、lambda匿名函数等）

---

### 说一说你了解的关于lambda函数的全部知识

1. 格式
    `[]()->xx{}`
    1. `[]` 为捕获列表, 捕获可以按值捕获/按引用捕获/混合捕获;
        按值捕获 `=` / 按引用捕获 `&` / 混合捕获 `[=, xx, xx]` `[&, xx, xx]`
    2. `()` 参数列表
    3. `xx` 为返回值类型, 可省略;
    4. `{}` 为函数体

2. 提供了一种便捷的方式来编写简洁、**内联** 的函数代码

---

### std::function

头文件<functional>

1. `std::function` 是一个函数包装器, 可以包装可调用实体, 如普通函数/函数对象/lamda表达式等

---

### 移动语义

1. 移动语义是指将一块内存单元从一个对象转移到另一个对象

2. 分类
    ![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202311232236103.png)
    表达式分为 泛左值 + 右值;
    泛左值又分为 左值 + 将亡值, 具名;
    右值又分为 将亡值 + 纯右值, 可移动;
    即 左值:具名不可移动; 将亡值:具名可移动; 纯右值:不具名可移动;

3. 泛左值来源
    1. 左值经 `std:move` 转换
    2. 将纯右值作为返回值时, C++17编译器会将其优化为将亡值

---

### 分别写出在 if 语句的条件中，如何判断 bool a, int a, float a, char *a 是否为“零”

### 以int变量为对象，设计一个类，给出所有成员函数的声明(类似格式的声明只需要写一个)

### 请解释32位/64位系统具体指的是什么长度，对系统有何影响？

### 简述系统物理内存与虚拟内存之间的联系与区别

### 简述你熟悉的编译器的不同的优化级别，以及编译器优化一些基本的思想

### 函数 bool less(float x, float y) { return \*(int \*)&x < \*(int \*)&y; } 是否能正确计算float的大小关系，为何？对应了c++的那种类型转换？

### 有一个 char*p={"abcdefg...z"} 的字符串，这个字符串强转成int型指针，再进行自增运算，求该值

### 谈一下模板 template

### 定义函数时，缺省函数的返回值类型，则函数的返回值类型为

A.float     B.int       C.char      D.void

### 要实现动态连编，必须使用（）调用虚函数？

A.类名      B.派生类指针        C.对象名       D.基类指针

## 面向对象

---

### 面向过程 和 面向对象 的区别？

---

### 面向对象的三大特性有哪些？

1. 封装
    封装是将数据和操作捆绑在一起, 形成一个单个实体, 即类
    通过封装对外部隐藏了实现细节, 这样可以实现数据的 **安全性** 和 **可维护性**, 同时提供了对数据的访问控制

2. 继承
    1. 继承是一种通过已有类创建新类的机制
    2. 通过继承，新创建的类(派生类)可以继承现有类(基类)的属性和方法, 并且可以在此基础上进行扩展或修改
    3. 继承提供了代码重用的机制，可以减少重复编写相似功能的代码, 并且支持建立类之间的层次关系
    4. 但是当父类中的成员变量、 成员函数或者类本身被 `final` 关键字修饰时, 修饰的类不能继承, 修饰的成员不能重写或修改

3. 多态
    1. 多态是指相同的接口(方法) 可以在不同的对象上具有不同的实现
    2. 允许使用基类的指针或引用来调用派生类的方法, 在运行时根据对象的实际类型来确定调用的函数
    3. 多态性提高了代码的 **灵活性** 和 **可扩展性**, 使得可以通过统一的接口处理不同类型的对象

---

### 什么是多态？多态分为哪几种，多态的应用场景有哪些？

多态是指相同的接口(方法) 可以在不同的对象上具有不同的实现

1. 静态多态
    1. 即 **编译时多态**, 即 在编译时就确定了要调用的方法, 也就是我们说的 函数重载 (overload)
    2. 函数重载 允许在同一个作用域内定义多个 函数名称相同 但 参数列表(类型/顺序/个数)不同的 函数
    3. 编译器在编译时会根据调用的参数列表选择对应的函数
    4. 因为在编译时就确定了需要调用的函数, 所以效率高, 但是灵活性差
    5. 函数重载 是通过 **名字改编** 实现的

2. 动态多态
    1. 即 **运行时多态**, 也叫做 **子类型多态** 也就是我们平常说的多态;
    2. 基类中定义了虚函数
    3. 派生类继承基类, 并对基类中的虚函数进行 **重写**(override)
    4. 创建派生类对象
    5. 使用基类指针指向派生类对象 或 使用基类引用绑定派生类对象, 并通过 基类指针/引用 调用虚函数
    6. 会在运行时根据 指针实际指向 或 引用实际绑定 的对象来确定要调用的函数
    7. 需要通过 **虚表** 完成

3. 参数多态
    1. 即 **函数模板**, 也即泛型编程
    2. 函数模板允许定义通用的函数, 该函数可以接受不同的参数
    3. 编译器进行编译时可以根据参数类型生成对应的 函数实例

---

### 动态多态的实现过程，静态多态的实现过程

[见 上一题](#什么是多态？多态分为哪几种，多态的应用场景有哪些？)

---

### C++的多态如何实现

---

### 空类里有什么函数？

### A继承B、C两个空类，对A进行强转成B、C，地址空间有什么变化呢？

### public/priavate 继承的关系

### 公有继承 和 私有继承 的应用场景？

### 基类和派生类的 构造函数 和 析构函数 的执行顺序？

1. 构造函数

    1. 先执行 基类 的 构造函数
    2. 再执行 成员子对象 的构造函数
    3. 最后执行 派生类 的构造函数

    补充:
    1. 先调用派生类构造函数, 然后在派生类构造函数的初始化列表中会 调用基类构造函数;
        故 从调用顺序上来看 是先调用 派生类构造函数 再调用基类构造函数, 但是 从实际构造顺序上来看, 先构造基类部分, 再构造派生类部分
        故 可以认为 是先执行的 基类构造函数, 再执行的派生类构造函数
    2. 派生类的构造函数若没有显式调用基类的构造函数, 则创建派生类对象时会自动调用 无参构造; 若基类无 无参构造, 则派生类创建失败
    3. 当派生类对象调用基类构造时, 希望使用非默认的基类构造函数, 必须显式地在初始化列表中写出

2. 析构函数

    1. 先执行 派生类对象 的析构函数

    2. 执行完之后执行 成员子对象 的析构函数

    3. 最后执行 基类子对象 的析构函数  

        ![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202309181130840.png)

---

### string 底层实现方式

1. 深拷贝
2. 写时复制
3. 短字符串优化(SSO)

---

### 谈谈深拷贝和浅拷贝，以及如何实现？

---

### string 的赋值操作是深拷贝还是浅拷贝？

---

### string 的 SSO 模式

短字符串优化 (Short String Optimization)

1. 概述  
字符串的长度小于等于15个字节时, buffer直接存放整个字符串;  
当字符串长度大于15个字节时, buffer存放的是一个指针, 指向堆空间的区域;  
**注意:** 对象地址 指向低地址, 内容地址 指向高地址
![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202309151635349.png)

2. 当在栈上创建字符串时
    1. len <= 15, str内容分布在栈上;
    2. len > 15, str内容分布在堆上;  

---

### 什么时候重载 赋值运算符 与 复制拷贝函数？

当对象的数据成员申请了 **堆上** 的空间

---

### 什么地方需要用到拷贝构造函数？

### virtual()=0 是什么意思？

### 虚函数和虚继承是怎么实现？

### 如果我有一块地址空间，我怎么在这个地址空间内调用构造函数？

### sizeof(A) 是多少？

``` c++
class A {
    int a;
    short b;
    double c;
    virtual void fun() {}
    static int d;
};
```

## STL

### STL包括哪些内容？

1. 容器
2. 迭代器
3. 算法
4. 适配器
5. 函数对象
6. 空间配置器

---

### vector底层实现

1. 由 3 个指针构成
2. `_start` 指向当前数组中第一个元素存放的位置
3. `_finish` 指向当前数组中最后一个元素存放的下一个位置
4. `_end_of_storage` 指向当前容器存放的最后一个元素的下一个位置
5. vector 中的元素存在 堆上
    ![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/image-20230908175603277.png)

---

### vector 和 deque 的区别？

vector 是一段连续的空间; deque 在逻辑上连续, 物理上是不连续的

1. 特点:
    1. 逻辑上连续, 物理上不连续
    2. 片段之间是依靠中控器数组进行控制的
        ![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202309261033477.png)  
        ![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202309261057206.png)
        ![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202309261104426.png)
        ![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202311241024104.png)

---

### vector 和 list 的本质区别？

### vector、list在添加删除的效率方面有什么不同？

---

### 释放 vector 的内存的处理方式

1. `clear()`
    将容器中的元素清空, 并且保留容器的容量不变; 可以释放元素占用的内存，保留容量可以避免重新分配内存的开销, 以备后续再次存储元素使用

2. `shrink_to_fit()`
    可以将容器容量减少至当前大小, 释放多余内存

3. 析构函数

---

### vector 迭代器失效的情况有哪些？

1. vector 迭代器失效
    1. 概念: 底层发生扩容现象, 而迭代器还指向老的空间, 使用 老的迭代器 去操作 新的空间  
    2. 解决方案: vector 每次插入前重新置位(获取) 迭代器
    3. insert 扩容策略
        size() = m, capacity() = n, 待插入的元素的个数 t
        1. t < n - m; 此时就不会扩容
        2. n - m < t < m; 会按照 2*m 进行扩容
        3. n - m < t, m < t; 会按照 m+t 进行扩容

        push_back 每次插入元素的个数都是固定的 1, 所以按照 两倍 进行扩容肯定容器是足够的;  
        但是 insert 进行插入元素的时候, 元素的个数是不一定的, 所以不能按照某个固定值的两倍进行扩容.

2. 解决方案
    1. 进行修改操作后, 重新获取新的迭代器
    2. 对于vector, 可以使用索引代替迭代器进行访问
    3. 如果需要在循环中进行修改操作, 并且需要同时使用迭代器, 可以考虑使用 **迭代器的返回值** 来更新迭代器
        如 insert()、erase() 会返回指向被插入或删除元素位置的迭代器

---

### 迭代器失效问题

vector/unordered_map/unordered_set

---

### map 和 unordered_map 的区别

1. 底层实现
    map 底层实现为红黑树, unordered_map 底层实现为 hash

2. 有序性
    map 是一个有序容器, 它根据**键值**进行排序;
    unordered_map 是一个无序容器

3. 查找操作
    1. map 查找的时间复杂度为 O(log n)的元素数量。且提供额外操作, 如 `lower_bound()` 和 `upper_bound()`
        `lower_bound` 返回首个 >= 给定值的迭代器
        `upper_bound` 返回首个 > 给定值的迭代器
        ![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202311241101045.png)
    2. unordered_map 查找的时间复杂度为 O(1)

4. 迭代器稳定性：

    map 的迭代器在插入和删除操作后仍然有效, 不会失效
    unordered_map 的插入和删除操作可能会导致哈希表的重新哈希, 从而使得迭代器失效

---

### stl 中的 unordered_map 和 unordered_set 有什么区别呢？

---

### 自己实现 unordered_map 的话，你会考虑到什么问题呢？

---

### clear 和 erase 的区别？

1. clear() 用于清空容器中的所有元素, 将容器恢复为空, 不释放内存
    erase() 用于删除容器中的一个或多个元素, 可以通过指定位置或迭代器来删除, 会使得后续元素向前移动, 容器大小减少
2. clear() 不会使迭代器失效, 而 erase() 可能会使迭代器失效

---

### erase 的返回值

返回指向待删除元素下一个元素的迭代器

---

### swap 函数的作用？

### 简述一下STL容器相关知识、特性等？

### stl 当中 vector、list、map 在内存中的数据结构有什么区别？

## Linux

### 说说 Linux 中常用的命令？

1. `ls`：列出目录中的文件和子目录。
2. `cd`：改变当前工作目录。
3. `pwd`：显示当前工作目录的路径。
4. `mkdir`：创建一个新的目录。
5. `touch`
6. `rm`：删除文件或目录。
7. `cp`：复制文件或目录。
8. `mv`：移动文件或目录，也可用于重命名文件或目录。
9. `cat`：查看文件内容。
10. `tail`:
11. `head`:
12. `echo`:
13. `grep`：在文件中搜索指定的模式。
14. `find`：在文件系统中查找文件或目录。
15. `chmod`：修改文件或目录的权限。
16. `tar`：创建或提取 tar 归档文件。
17. `gzip`：压缩文件。
18. `unzip`：解压缩文件。
19. `kill`：终止运行中的进程。
20. `ifconfig`：查看和配置网络接口信息。
21. `ping`：测试与另一台计算机的连通性。
22. `ssh`：通过安全的远程登录协议连接到远程主机。
23. `scp`：通过安全的远程拷贝协议在本地主机和远程主机之间复制文件。
24. `alias`
25. `su`
26. `sudo`
27. `useradd`
28. `usermod`
29. `userdel`
30. `ln -s`

31. `ps`：显示当前运行进程的快照。
32. `top`：实时显示系统资源使用情况和进程信息。
33. `netstat`
34. `tcpdump`
35. `valgrind --tool=memcheck --leak-check=full --show-reachable=yesvmemcheck`

### 创建软连接的命令是什么？

`ln -s <target> <link_name>`

### /proc文件夹下放的是什么？

### Linux下有哪些文件类型？

### Linux查看内存、磁盘、端口、进程、线程命令有哪些？

---

### gdb的基本使用 (重新运行程序)

1. 编译源代码时加上 `-g` 选项用于生成调试信息

2. 进入调试界面
    1. 方法1: 直接设置命令行参数
        `gdb --args exe xxx xxx`

    2. 方法2: 进入后再设置命令行参数
        `gdb exe`
        `set args xxx xxx`

3. `r` 运行程序到报错的地方
    `bt` 查看函数调用栈, 从上往下定位问题, 找到出错的代码位置
    `x` 可以查看内存
    常见问题:
    1. 指针: 解引用/下标/函数调用
    2. 数组: 越界

4. 其他命令
    1. 设置断点: b
    2. 查看断点信息: i
    3. 删除断点: d
    4. 继续: c
    5. 单步调试: s
    6. 逐过程: n
    7. 打印表达式的值: p

5. 退出 gdb
    `q`

---

### gdb的基本使用 (调试已运行程序)

1. 编译源代码时加上 `-g` 选项用于生成调试信息

2. 打开一个终端, 使用 `ps` 或 `top` 查找异常进程的 pid

3. 进入 gdb 使用 `attach pid`, 连接到异常进程

4. 进行调试, 步骤同[上题](#gdb的基本使用-(重新运行程序))

5. 调试完成使用 `detach`, 脱离异常进程

---

### 是否在linux系统下用过gdb或者别的调试工具，对于gdb来说，用过哪些功能？

1. gdb 见[上题](#gdb的基本使用-(调试已运行程序)

2. valgrind: 内存分析与调试工具

3. tcpdump: 网络抓包工具

4. perf: 性能分析工具

---

### gdb 用法如果堆栈的信息不准，怎么办（不能运行，不能修改代码），可能是是哪里出了问题

1. 缺少调试信息: 编译时使用 `-g` 选项生成调试信息

2. 优化编译优化过高: 使用较低的优化级别重新编译程序, 如 `-O0`

3. 多线程或信号处理

4. 野指针或内存损坏: 使用内存检测工具来检测和定位内存错误, 如 valgrind 的 memcheck

---

### 什么是 coredump 文件？怎么调试？

1. 程序异常终止时产生的文件, 会保留程序"异常"瞬间的一些信息, 如寄存器的状态/栈调用情况
    常用于辅助分析和 Debug

2. 进入 gdb 界面调试, 过程与 gdb 相同, 见[gdb调试运行程序](#gdb的基本使用-(调试已运行程序))
    `gdb exe coredumpName`

---

### 如果某个模块运行过程中突然崩溃，但是崩溃的几率不大，如何定位并解决这个问题？

1. 生成 coredump 文件

    ```shell
    设置Coredump文件的格式
    sudo vim /etc/sysctl.conf
    kernel.core_pattern = %e_core_%s_%t 
    # %e:executable-name 
    # %s:signal 
    # %t:time

    # 让配置生效
    sudo sysctl -p 
    ```

2. 借助 coredump 文件进行调试, 见[上一题](#什么是-coredump-文件？怎么调试？)

---

### 如果是在一个循环内出现问题，使用gdb调试需要等待很长时间，应该怎么处理？

---

### 内存泄漏怎么检查，怎么避免？

1. 使用 `valgrind --tool=memcheck --leak-check=full --show-reachable=yesvmemcheck` 进行内存检查, 寻找产生内存泄露的地方, 进行修改

2. 避免内存泄漏可以使用 RAII 思想, 即利用栈对象的生命周期管理资源, 当执行构造函数的时候申请资源, 执行析构函数的时候释放资源;
    智能指针, 如 unique_ptr/shared_ptr/weak_ptr

---

### 什么时候用静态库和什么时候用动态库，两者有何区别？

### 零拷贝技术有哪些？

### mmap的应用场景有哪些？

### linux文件系统读入文件的过程

---

### 线程 和 进程区别？

进程是内存分配的最小单位
线程是 CPU 分配的最小单位

---

### 中断和异常的区别

### 进程和线程的本质区别

### 多进程和多线程的区别是什么？换句话说，什么时候该用多线程，什么时候该用多进程？

---

### 进程间通信的方式有哪些？

1. 匿名管道
2. 有名管道
3. 共享内存
4. 信号量
5. 信号
6. socket
7. 消息队列

---

### 线程间通信的方式？

### Linux程序运行找不到动态库.so文件的三种解决办法

### Linux进程同步的机制

### 什么是同步、异步？什么是阻塞、非阻塞？

### 进程的六种状态

---

### 什么是孤儿进程？什么是僵尸进程？怎么避免僵尸进程？

1. 孤儿进程: 父进程在子进程之前终止
2. 僵尸进程: 子进程终止, 但父进程未对其进行资源回收
3. 避免僵尸进程
    1. 父进程调用进程管理函数等待子进程终止, 如 wait(), waitpid();

---

### 结束进程的方式有哪些？

---

### buffer 与 cache 区别

1. buffer 为缓冲区, 底层实现为队列, 先进先出, 用于平衡设备间速率差异

2. cache 为缓存/快取, 是在高速设备上拷贝一份低速设备的数据, 目的是提高性能

---

### 什么是会话(session)？

### 守护进程与后台进程的区别

### 守护进程的实现

1. 创建新会话

2. 修改与启动环境相关的属性, 如当前工作目录/文件掩码(cwd, umask)

3. 断开文件(close stdin/stdout/stderr), 将运行信息写入日志系统

### 写时拷贝

### 自旋锁

### 谈一下对多线程的理解，如生产者 - 消费者问题

### 什么是死锁？死锁产生的条件？怎么解决死锁问题？

### 信号量处理耗费多长时间，信号量同步会有什么问题

### 登录 shell 进程是如何启动的？shell 是如何调用系统调用的？

### sleep()调用后进程有哪些过程，在sleep()的过程中进程占用CPU了吗？

### 线程池有什么好处？

### 讲一下线程池？

### 什么是线程安全？

### 多线程间共享数据，用什么方式来保存它们的安全性

加锁

### 什么是线程安全函数，工作中如何保证线程安全

### 可重入函数是什么意思，为什么一定是线程安全的

## 网络

### 网络的七层模型？每一层的协议？

### 简述 OSI 七层模型和 TCP/IP 四层模式

1. OSI 七层
    1. 应用层: HTTP/HTTPS/FTP
    2. 表示层:
    3. 会话层:
    4. 传输层: TCP/UDP
    5. 网络层: IP/ICMP
    6. 数据链路层:
    7. 物理层:

2. TCP/IP 四层
    1. 应用层
    2. 传输层
    3. 网络层
    4. 网际接口处

### 请描述一下从输入URL到显示页面的全过程

1. DNS解析
    ![](https://mmbiz.qpic.cn/mmbiz_png/7GKGqTM0p0NSXf1TNvujm0c2HpUy9jrtlwkWu9kp0J87IgFxNodUkmTCm3QB02ksb1SrtA46UX8TlqibT5P1dXw/640?wx_fmt=png&from=appmsg&wxfrom=5&wx_lazy=1&wx_co=1)
    浏览器首先会检查网址中的域名部分（例如，www.xxxxx.com）。
    浏览器会向本地DNS缓存查询，如果之前已经解析过这个域名，就可以跳过后续步骤。
    如果没有找到缓存，浏览器会向操作系统的DNS解析器发送请求，请求解析该域名的IP地址。
    DNS解析器可能会向根域名服务器、顶级域名服务器、权威域名服务器等层级进行查询，直到找到该域名对应的IP地址。
    一旦获取到IP地址，浏览器就知道要连接的服务器位置。
2. 建立 TCP 连接
    浏览器使用获取到的IP地址和HTTP默认端口（通常是80，或者443用于HTTPS）来建立与Web服务器的TCP连接。
    这个过程包括TCP的三次握手，确保浏览器和服务器之间的可靠通信。
3. 发送HTTP请求：
    浏览器向服务器发送一个HTTP请求，该请求包括请求的资源、请求方法（GET、POST等）、HTTP协议版本以及其他一些头部信息。
    服务器根据请求的资源路径和方法来响应请求，通常会检查请求头中的一些信息，如Cookie、User-Agent等。
4. 服务器处理请求：
    服务器根据HTTP请求的内容来执行相应的处理，这可能包括查询数据库、调用应用程序、生成动态内容等。
    服务器生成HTTP响应，包括响应状态码、响应头和响应正文。
5. 接收响应：
    浏览器接收到来自服务器的HTTP响应。
    如果响应状态码指示成功（例如，200 OK），浏览器将继续处理响应。
6. 渲染页面：
    浏览器根据响应中的HTML、CSS和JavaScript开始渲染页面。
    浏览器解析HTML文档，构建DOM（文档对象模型）树。
    浏览器解析CSS，构建CSSOM（CSS对象模型）树。
    浏览器将DOM和CSSOM合并成一个渲染树，用于确定页面上各个元素的布局和样式。
    浏览器执行JavaScript，可以修改DOM和CSSOM，以及处理用户交互。
    浏览器根据渲染树绘制页面。
7. 显示页面：
    浏览器将渲染页面的结果显示在用户的屏幕上。
    这包括文本、图像、多媒体元素等。
    浏览器还处理用户的交互事件，如鼠标点击和键盘输入。
8. 持续通信：
    如果页面包含与服务器的WebSocket或长轮询等通信，浏览器将保持与服务器的连接，以接收实时数据。

### 简述一下 socket 编程的流程



### write 阻塞的原因有哪些？

---

### IO 多路复用：select, poll, epoll 的区别？epoll 的底层是如何实现的？

1. select
    1. 底层
        1024 bit 的位图
    2. 缺点
        1. 上限 1024, 不好修改
        2. 大量内核 与 用户态之间的 数据拷贝
        3. 监听 与 就绪集合 耦合, 每次调用前都需要重新设置监听集合
        4. 就绪检查不合理, 当海量连接少量就绪时 需要遍历所有连接, 依次判断是否就绪(FD_ISSET)

2. poll
    1. 底层
        文件描述符储存于结构体中, 储存于结构体数组中
    2. 改进
        1. poll 无最大文件描述符数量的限制
    3. 缺点
        1. 仍然存在大量 用户态 与 内核态之间的数据拷贝
        2. 就绪检查仍存在问题, 得到就绪集合后 需要遍历就绪集合判断 是否就绪 XXXXX

3. epoll
    1. 底层
        ![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202309302054214.png)
    2. 改进
        1. 数据结构分配在内核态文件对象
        2. 文件对象内有两个集合 (监听/就绪)
        3. 监听集合 底层实现为 <mark>红黑树</mark>, 方便新增, 查找效率高
        4. 就绪集合 底层实现为 <mark>线性表</mark>, 用户只需便利就绪集合

---

### epoll边沿触发具体实现方式

---

### LT 和 ET 的区别, 应用场景？

1. 水平触发: 只要缓冲区有数据, epoll_wait 就会一直被触发, 直到缓冲区为空;
2. 边缘触发: 只有监听的事件状态改变或者有事件发生时, epol_wait 才会被触发;
    一般结合非阻塞 IO 来使用

---

### 说说同步、异步、阻塞、非阻塞

### 调用 send 函数发送数据不全怎么办？

### 1G 的文件从 A 机器发送到 B 机器，怎么发？(写代码实现)

---

### 什么是 TCP 的"粘包"问题？怎么解决？

1. 粘包问题
    因 TCP 是面向字节流的协议, 消息之间没有边界;
    故在数据传输过程中, 发送方发送的若干个数据包可能会被接收方一次性接收, 导致数据粘在一起, 难以正确解析;

2. 解决方案
    1. 发送方在发送每个数据包之前都先发送一个固定长度的字段, 比如占 4B 的整数字段, 整数表示后面数据包的长度;
    2. 接收方首先接收固定长度的字段, 然后解析出后续数据包的长度, 然后再开始数据包的接收;

---

### TCP 和 UDP 的区别？

1. TCP 是面向连接的协议; UDP 是无连接的协议;

2. TCP 是可靠传输; UDP 是不可靠传输;

3. TCP 是面向字节流的协议, 数据传输无边界; UDP 是面向报文的, 数据传输有边界;

4. TCP 不支持广播; UDP 支持广播;

5. TCP 适用于对数据完整性和有序性要求较高的应用;
    UDP 适用于实时性要求较高、对数据可靠性要求较低的应用;

---

### tcp 三次握手建立连接的过程？三次握手过程通信双方各自的状态？

### tcp 四次挥手的过程？四次挥手过程中通信双方各自的状态？

### 从实用的角度来讲，三次握手的真实目的？（从硬件的角度来看，每一次握手的意义？）

![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202311251301816.png)

在建立连接之前，Client处于CLOSED状态，而Server处于LISTEN的状态。

1. 第一次握手
    客户端主动给服务端发送一个SYN报文，并携带自己的初始化序列号一起发送给服务端。此时客户端处于一个SYN_SEND的状态。
2. 第二次握手
    服务端收到客户端发来的SYN报文之后，就会以自己的SYN报文作为应答，然后将自己的初始化序列号发送给客户端，并且会将客户端的初始化序列号+1作为自己的ACK值发送给客户端，以表示自己已经收到了客户端的SYN报文。此时服务端处于一个SYN_RECV的状态。
3. 第三次握手
    客户端收到服务端发来的SYN报文之后，会把服务端的初始化序列号+1作为ACK值发送给服务端，用来表示自己已经收到了服务端发来的SYN报文。此时客户端处于一个ESTABLISHED的状态。

---

### 简述一下 tcp 的超时机制

---

### tcp 通信过程的状态是如何变化的

---

### 为什么 TIME_WAIT 状态需要经过 2MSL 才能返回到 CLOSE状态

---

### 什么时候会产生 time_wait，如果系统出现大规模time_wait怎么处理？

---

### TCP 利用滑动窗口实现流量控制的机制？

---

### 如何根据IP获取对方的MAC地址？ARP协议了解一下

---

### Proactor 和 Reactor 的区别和特点

1. Reactor (反应器模式)
    同步: 用户态进程 主动要找 内核态进程要数据;
    关注的是 IO 就绪事件(读写事件)
    1. 注册 X就绪事件 及 事件处理器
    2. 事件分离器 等待就绪事件的发生
    3. 当 X就绪事件 发生时, 事件分离器 执行相应的 事件处理器

2. Proactor
    异步: 用户态进程与内核态进程有自己的执行流, 彼此并不干涉; 用户态进程不会主动找内核态要数据
    关注的是 IO 完成事件(读写完成事件)
    1. 注册 X完成事件 和 事件处理器
    2. 事件分离器 要等待事件的发生
    3. 当 X完成事件 触发时, 事件分离器 执行相应的 事件处理器

    用户态与内核态交互流程:
    1. 用户态进程会事先指定给内核态一个空间
    2. 用户态进程自己去处理自己的事儿，不需要等待数据的到来
    3. 内核态主动将数据放到用户态进程指定的空间
    4. 内核态通知用户态进程去处理数据
    5. 用户态进程收到通知去处理数据
    ![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202311211606451.png)

3. 理论上来说, Proactor效率更高, 但是实际实现时有难度, 需要硬件的支持(DMA)实际实现时, 很有可能是用同步来模拟异步, 也是用epoll来实现的, 对epoll进行了封装, 生成一个组件

---

### 怎样加快大文件在网络中传输，根据滑动窗口与拥塞控制考虑

---

### http 和 https 的区别？

1. 安全性
    1. HTTP 是明文传输的协议, 数据在传输过程中不加密, 容易被窃听和篡改
    2. HTTPS 使用 SSL/TLS 进行加密和认证, 提供了更高的安全性

2. 端口号
    1. HTTP 端口号 80
    2. HTTPS 端口号 443

3. 证书
    HTTPS 使用 SSL/TLS 证书来验证服务器的身份, 以确保连接的安全性

4. 连接建立过程
    1. HTTP 客户端和服务器之间的连接是无状态的, 每个请求和响应之间都是独立的
    2. HTTPS 由于使用了 SSL/TLS 协议, 客户端和服务器在建立连接时需要进行握手过程, 以协商加密算法、验证证书等信息, 这增加了一定的延迟

---

### HTTP有哪些常用方法？HTTP端口号？

1. 端口号 80

2. 常用方法
    1. GET: 获取资源
    2. POST: 提交资源
    3. PUT: 更新资源
    4. DELETE: 删除资源
    5. HEAD: 获取请求头数据

---

### SSH 基于 TCP 还是 UDP？端口号？

1. TCP

2. 22

---

### 常用端口

http 80
https 443
ftp 21控制/20传输
dns 53
ssh22
mysql 3306
redis 6379

---

### HTTP 特点

1. C/S模型
    请求-响应 -> 远程过程调用(RPC)
2. 可靠 基于TCP协议
3. 无状态: 每次HTTP请求都是独立的, 不依赖于上一个请求
4. 文本协议

### 讲一下WLAN？

### 网卡的中断、几级缓存、网络方面遇到瓶颈怎么解决？

## 数据结构与算法

## 链表

### 红黑树的思想，红黑树的特点，红黑树和平衡二叉树的区别？红黑树的查找为什么是O(logn)?

### 负载均衡算法

### 海量数据Top K问题

### 有损压缩和无损压缩算法

### 三个有序的序列，查找公共的部分

### 合并两个有序数组或链表

### 实现一个栈，实现O(1)时间复杂度求栈的最小元素

### 100G的文本，每行80k还是80字符，提示用多个机器，多进程，多线程，求出重复最多的行。一内存8G，计算每个机器大概分多少？能读取100G的文本吗？找重复率前十的文本

### 两数之和(leetocde第一题)

### 将奇数放于数组前面，偶数放于后面

### 设计一个可以求最大值的栈

### 余弦相似度算法

### 如何判断单链表是否有环？

### 反转单链表

### 怎么判断单链表是否相交？

### B树和B+树的特点以及应用场景？

### hashmap实现的思路和方法(类似于STL中的unordered_map)

### Hash表处理冲突的方式有什么？

### 说一下什么是一致性哈希

### 最短编辑距离问题

### LRU 实现原理

### 邻接矩阵是什么？

### 贪心算法是什么，怎么保证最后的结果是最优的？

## 树

### 二叉树的深度优先遍历：先序，中序，后序

### 二叉树层次遍历

### 二叉树镜像反转

### 假设数组为{3,5,7,4,6,2,1},构建一个二叉排序树,并输出排序结果

    a)代码实现
    b)简述思路

## 排序

---

### 请实现冒泡排序

```c++
// 冒泡排序
void bubbleSort(vector<int> &arr, int n) {
    for (int j = 1; j < n; ++j) {
        for (int i = 0; i < n-j; ++i) {
            if (arr[i] > arr[i+1]) {
                int tmp = arr[i];
                arr[i] = arr[i+1];
                arr[i+1] = tmp;
            }
        }
    }
}
```

---

### 选择排序

```c++
void selectionSort(vector<int> &arr, int n) {
    for (int i = 0; i < n; ++i) {

        int minIndex = i;
        for (int j = i+1; j < n; ++j) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j;
            }
        }

        if (minIndex != i) {
            int tmp = arr[i];
            arr[i] = arr[minIndex];
            arr[minIndex] = tmp;
        }
    }
}
```

---

### 插入排序

```c++
void insertionSort(vector<int> &arr, int n) {

    for (int i = 1; i < n; ++i) {
        int tmp = arr[i];
        int j = i-1;
        while (j >= 0 && arr[j] > tmp) {
            arr[j+1] = arr[j];
            --j;
        }
        arr[j+1] = tmp;
    }
}
```

---

### 请实现归并排序

```c
#define SIZE(a) (sizeof(a) / sizeof(a[0]))
#define N 10
int tmp[N];

void merge_sort(int arr[], int n) {
    // 委托
    merge_sort_helper(arr, 0, n-1);
}

void merge_sort_helper(int arr[], int left, int right) {
    // 边界条件
    if (left >= right)
        return ;

    // left + right 有可能溢出
    // 运算符优先级 
    int mid = left + (right - left >> 1);
    merge_sort_helper(arr, left, mid);
    merge_sort_helper(arr, mid + 1, right);

    merge(arr, left, mid, right);
}

// left, right 代表 排序区域的 最小/大 索引
void merge(int arr[], int left, int mid, int right) {
    int i, j, k;
    i = left;
    j = mid+1;
    k = 0;

    while (i <= mid && j <= right) {
        // = 保证了排序是稳定的
        if (arr[i] <= arr[j])
            tmp[k++] = arr[i++];
        else
            tmp[k++] = arr[j++];
    }

    while (i <= mid) {
        tmp[k++] = arr[i++];
    }

    while (j <= right) {
        tmp[k++] = arr[j++];
    }

    for (int i = 0; i < k; ++i) {
        arr[left + i] = tmp[i];
    }
}
```

---

### 请实现快速排序

```c
// 宏函数, 用于交换 arr 数组中索引为 i, j 的两项
#define SWAP(arr, i, j) {   \
    void* tmp = arr[i];     \
    arr[i] = arr[j];        \
    arr[j] = tmp; }
          
#define SIZE(a) (sizeof(a) / sizeof(a[0]))
          
void quick_sort(int arr[], int n) {
    srand(time(NULL));
    // 委托 [0, n-1]
    quick_sort_helper(arr, 0, n - 1);
}

void quick_sort_helper(int arr[], int left, int right) {
    if (left >= right)
        return;

    // idx 为 基准值最终索引
    int idx = partition(arr, left, right);

    quick_sort_helper(arr, left, idx - 1);
    quick_sort_helper(arr, idx + 1, right);
}

int partition(int arr[], int left, int right) {
    // 双向分区, 最左侧元素作为基准值
    int pivot = arr[left];

    int i = left, j = right;

    while (i < j) {
        // 先移 j
        while (i < j && arr[j] >= pivot)
            --j;
        // i == j || arr[j] < pivot
        arr[i] = arr[j];

        // 后移 i
        while (i < j && arr[i] <= pivot)
            ++i;
        // i == j ||arr[i] > pivot
        arr[j] = arr[i];
    }
          
    // i == j
    arr[i] = pivot;

    return i;
}
```

---

### 快速排序算法思想？

### 快排和堆排的应用场景

### 简述你所知道的std::sort实现方法

### 写一个排序函数，时间复杂度不大于O(nlogn)，如果有多线程时该排序算法可如何优化，或者无法多线程优化的原因

## 查找

### 设计一个目标字符串查询系统，输入一个目标字符串，找出磁盘上40亿个字符串中和目标字符串完全匹配的字符串，可以对40亿个字符串（数据量> 100GB，服务器可用内存为8GB）进行预处理

    a. 如果目标是尽可能快的完成字符串搜索工作，应该如何设计。
    b. 如果不仅需要找到目标字符串还需要返回按字典序排在该字符串后面的字符串数量，又该如何设计呢？

### 实现二分查找算法

## Leetcode

    8，21，39，86，127，146

## 其它题目

### 有一个包含4个字节的数 a，将它的每个字节相加，结果对 b 取模，如果结果小于c则称之为有效数，统计输入的数字中包含有效数的个数

    输入：c b  10个数   例：3 4 256 257 258 259 260 261 262 263 264 265
    输出：有效数的个数   例：4

### 如果一个字符串符合“辅音+元音(aeiou)+辅音(除了r)+e"的格式，则称它为有效字符串。输入一组字符串，用空格区分，如果单词中不包含非字母元素，则将单词翻转，统计翻转后的每个单词中包含有效字符串的个数，输出其中的最大值

    输入：一组字符串    例：!maxe a ekekac
    输出：最大值        例：2
    分析：!maxe a ekekac翻转后为!maxe a cakeke。cakeke中有两个有效字符串cake和keke，故输出2。

### solo 和 koko 是两兄弟，两人分一堆积木，每块积木都有自己的重量，弟弟koko要求积木的重量必须相等，否则就会哭（按照koko的标准），可是koko只会将数字转化为二进制后相加，而且总会忘记进位（每次都会忘记）。solo应该如何分积木，才能使自己得到的积木重量尽可能大，如果不能则输出-1？

    输入：积木个数 每个积木的重量    例：3 3 5 6
    输出：solo能拿到积木的最大重量   例：11

### 给出字符串含 数字（0-9）和 ？ 例如（ ???1234?256??????3251? ）其中 ? 可以为任何数，求字符串转成数后 %13 = 5 的情况数量

    给的要求:字符串长度达到 10^5 ，数字前段可以为0

### 已知某栅格三角网上三个顶点A(x,y,z),B(x,y,z),C(x,y,z),求三角网范围内任意点的高程z

    a)代码实现
    b)简述思路

### 实现全排列

## 数据库

## MySQL

---

### 数据库事务是什么？

---

### 并发 4 问题

1. 脏写
    多个事务并发写入同一数据时, 先执行的事务所写数据 被后写的数据覆盖

2. 脏读
    一个事务 写入数据 且 未提交/终止, 另一事务便读取到了 写入的数据

3. 不可重复读
    一个事务 对同一数据项进行多次读取, 但是在两次读取间 另一事务修改了该数据项 并 进行了提交, 则 后一次读取到修改, 导致两次读取 信息不一致

4. 幻读
    一个事务 进行两次统计, 但是在两次统计期间 另一事务 添加了新的数据项 并且进行了提交, 则 后一次统计到修改, 导致两次统计信息不一致

---

### 数据库事务有哪些特性？ (ACID)

1. 原子性(Atomicity)  
    事务中的操作要么全部发生, 要么全部都不发生

2. 一致性(Consistency)
    事务执行前后, 数据的完整性保持一致 且 事务执行前后数据的总和不变

3. 隔离性(Isolation)

    1. 一个事务的执行不能被其他事务干扰, 即一个事务内部的操作 及 使用的数据 对并发的其他事务是 隔离的, 并发执行的各个事务之间不能互相干扰

    2. 两个事务之间是没有交集的

    3. 隔离性与隔离级别是有关的

4. 持久性(Durability)
    事务一旦提交, 对数据库中数据的改变就是永久性的, 直到其他事务将该数据发生修改

---

### 事务的隔离级别有多少种，分别是什么？

![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202310162058411.png)

1. 读未提交
2. 读已提交
3. 可重复读
4. 可串行化

### 不可重复读和幻读区别是什么？可以举个例子吗

1. 不可重复读是指同一事务内多次读取同一记录, 结果不一致
2. 解决不可重复读问题: 锁机制 或 更高的隔离级别来实现
3. 幻读是指同一事务内多次执行相同查询, 结果集中的记录数量不一致
4. 解决幻读问题: 使用间隙锁 或 更高的隔离级别

### 什么是聚合索引 ？什么是非聚合索引

1. 聚集索引
    将数据与索引合在一起存放。例如: InnoDB存储引擎。.idb

    1. 主键索引
        以主键创建的索引, 叶子节点存放的是 主键 与 本条数据除主键外的其他列信息

    2. 非主键索引(辅助索引)
        以非主键创建的索引。包括: <mark>唯一索引、普通索引、组合索引</mark>, 叶子节点存放的是 索引 与 以及对应的主键

        InnoDB存储引擎 使用 辅助索引 进行查询
        1. 如果查询的列在辅助索引树上都可以命中, 将这种情况称为索引覆盖(覆盖索引);
        2. 如果要查询的列在辅助索引树上没有命中, 会在辅助索引树的叶子结点下找到对应的主键, 然后使用主键在主键索引树上找其他的列, 这种情况称为 <mark>回表</mark>

2. 非聚集索引
    将数据与索引分开存在。例如:MyISAM存储引擎。.myd .myi
    叶子节点存放的是 索引 与 地址信息

    1. 主键索引
        以主键创建的索引, 叶子节点存储 主键 与 该列的地址信息

    2. 非主键索引(辅助索引)
        以非主键创建的索引。包括:<mark>唯一索引、普通索引、组合索引</mark>, 子节点存储 主键 与 该列的地址信息

### 数据库索引怎么用，适合什么场景，什么时候索引失效?

### 如何对索引进行优化？

### 创建索引一定能加快检索速度吗，为什么？

---

### 为什么 MySQL 索引要使用 B+ 树，而不是 B树或者红黑树？

1. 范围查询效率高
    B+ 树的叶子节点形成了一个有序链表, 可以方便地进行范围查询
    而 B 树和红黑树则需要通过中序遍历或其他方式来实现范围查询, 效率较低

2. 索引占用空间更小
    B+ 树的内部节点只存储键值信息, 而不存储具体的数据, 只有叶子节点包含了完整的数据行
    B 树和红黑树的每个节点都需要存储键值和数据信息, 导致索引占用的空间更大

3. 适合磁盘存储
    B+ 树的节点通常比较大, 可以容纳更多的键值, 减少了树的层数, 适合在磁盘上存储
    B 树和红黑树的节点较小, 树的高度较高, 在磁盘存储时需要更多的 IO 操作

---

### B 树 和 B+ 树区别

1. B 树
    1. 多叉树, 每个大节点中可以存放多条数据(小节点), 每个小节点会存储 **索引信息/数据信息/指向下一个节点的指针**, 相比于 二叉树, 可以降低树的高度, 进而较低磁盘 IO 的次数, 减少时间消耗;
    2. 但是 因为 每个而小节点还需要存放**数据信息**, 导致 每个大节点中存放的小节点个数有限

2. B+ 树
    1. 除叶节点外每个节点只会存储 索引/指向下一个节点的指针, 相比于 B 树, 每个大节点中存放的小节点个数更多, 树的高度会更低, IO 次数更少;
    2. 所有的 叶子节点 存储完整的一份 索引信息(Key) 以及 对应的data信息;
    3. 每一个父节点 都出现在子节点中, 是子节点的最大或者最小的元素;
    4. 每个叶子节点都有一个指针, 指向下一个节点, 形成一个链表

---

### 你知道哪些数据库结构优化的手段

### 怎么判断一个查询是否是高效率的？

### 如何优化查询语句？

### MySQL的约束有哪些？

### inner join, left join, right join, outer join 的区别？

### mysql 如何合并两个表?

---

### 共享锁与独占锁

1. 共享锁 (Shared Lock)
    **读锁**, 多个事务可以同时持有共享锁, 用于对同一资源进行读取操作, 彼此之间不会产生冲突
    共享锁阻止其他事务获取独占锁(写锁), 但不阻止其他事务获取共享锁

2. 独占锁 (Exclusive Lock)
    **写锁**, 只有一个事务可以持有独占锁, 用于对资源进行写入或修改操作
    独占锁与其他任何锁(共享锁或独占锁)都是互斥的

---

### 乐观锁和悲观锁

1. 悲观锁 (Pessimistic Locking)
    悲观锁认为在事务处理过程中会发生冲突, 因此在**访问数据之前**就会将其锁定, 阻止其他事务对数据进行修改
    适用于对数据进行长时间的修改操作, 适合于**写多读少**的场景
    悲观锁常用的实现方式是通过 **行级锁或表级锁** 来实现

2. 乐观锁 (Optimistic Locking)
    乐观锁认为在事务处理过程中不会发生冲突, 因此在**事务提交时**才会检查是否发生了冲突
    如果检测到冲突, 如数据已被其他事务修改, 则需要**回滚事务或重新尝试**
    乐观锁适用于**读多写少**的场景, 可以提高并发性能
    乐观锁通常使用**版本号或时间戳**等方式来实现, 每个数据项都有一个对应的版本号或时间戳, 事务在修改数据时需要比较版本号或时间戳, 判断是否发生了冲突

---

### 了解过存储过程吗？

### 了解过数据库视图吗

## Redis

### Redis常见数据结构以及使用场景分别是什么？

---

### Redis持久化机制可以说一说吗？

1. RDB快照 (Redis Database)
    在指定的时间间隔内将**Redis数据集**的状态保存到硬盘上的一个**二进制文件**中
    RDB持久化通过 `fork()` 子进程来完成持久化过程, 父进程继续处理客户端请求, 因此在持久化期间不会阻塞客户端操作
    RDB持久化适用于周期性备份数据，以及在Redis重新启动时快速加载大量数据的场景

2. AOF日志 (Append Only File)
    AOF持久化记录了Redis服务器接收到的所有**写操作命令**, 以追加的方式将命令写入到一个**文本文件**中
    AOF持久化适用于需要更精确的数据恢复, 并且可以提供更好的数据安全性保证的场景

3. 混合持久化

---

### 了解Redis的线程模型吗？可以大致说说吗？

### 有没有读过Redis源码

### C++中的Map也是一种缓存型数据结构，为什么不用Map，而选择Redis做缓存？

### Redis是如何部署的？

### 简述一下主从复制和哨兵模式的原理？

### 解释一下Redis缓存雪崩，缓存击穿，缓存穿透？

1. 缓存雪崩
    指在某个时间点, 缓存中大量缓存数据同时失效或过期, 导致大量的请求直接访问后端数据库, 从而造成数据库压力过大
    1. 将缓存失效时间分散开, 比如在原有的失效时间基础上增加一个随机值
    2. 不设置缓存的过期时间, 有更新操作时就把热点的缓存全部更新

2. 缓存击穿
    热点数据从缓存内失效时, 大量访问同时请求这个数据, 就会将查询下沉到数据库层, 导致数据库压力过大
    1. 延长热点key的过期时间或者设置永不过期
    2. 利用互斥锁保证同一时刻只有一个客户端可以查询底层数据库的这个数据

3. 缓存穿**透**
    要查询的数据不存在, 缓存无法命中所以需要查询完数据库, 但是数据是不存在的, 此时数据库肯定会返回空, 也就不会记录到缓存中, 这样每次对该数据的查询都会穿过缓存去查询一次数据库

### redis 的有序集合底层实现是什么？如果让你实现，你会怎么实现？

### redis 失效时应该怎么处理，如果让你设计你方案，你会怎么设计？

## 设计模式

---

### 设计原则

1. 单一职责原则
    类的职责要单一, 不能将太多的职责放在一个类中

2. 开闭原则
    软件实体**对扩展开放**的, 但**对修改关闭**的, 即在不修改一个软件的基础上去扩展其功能

3. 里氏替换
    在软件系统中, 一个可以接受基类对象的地方必然可以接收一个派生类对象

4. 依赖倒置原则
    要针对抽象编程, 而不是针对具体编程

5. 接口隔离原则
    使用多个专门的接口来取代一个统一的接口

6. 迪米特法则
    一个软件实体对其他实体的引用越少越好, 或者说如果两个类彼此直接通信, 那么这两个类就不应当发生直接相互作用, 而是通过引入一个第三者发生间接交互

7. 合成复用原则
    在系统中应该尽量多使用组合/聚合/关联关系, 尽量少使用甚至不使用继承关系

---

### 为什么用组合而不要用继承？

### 单例模式的构造函数？单例模式的创建过程？如何保证线程安全？

### 手写单例模式

---

### 如何使用单例模式，有什么注意事项？

1. 构造 / 析构函数 私有; 拷贝构造 / 赋值运算符 `delete`;
2. 局部静态变量实现单例模式 (C++11 线程安全)

```c++
class Single {
public:
    // 获取单实例对象
    static Single& GetInstance();

private:
    // 构造/析构 私有
    Single() {}
    ~Single() {}

    // 拷贝构造/赋值运算 delete
    Single(const Single &single) = delete;
    Single &operator=(const Single &single) = delete;
};

Single& Single::GetInstance() {
    static Single single;
    return single;
}
```

---

### 如果使用单例模式时创建了多个对象，如何定位问题？

### 请简述一下适配器模式？

### 实现一个简单的观察者模式

    a)代码实现

    b)简述思路

### 使用过的设计模式，应用场景，如何应用？阐述业务背景和应用的方式

## 项目

## 网盘项目

### 客户端发消息给服务器，服务器端是如何解析的？

### 多个用户上传同一份文件该如何处理？

### 秒传如何实现？

### 断点续传如何实现？

### 讲一下虚拟文件目录

### 前后端的通信方式知道哪几种？

### 当你上传文件或更改文件时，如果出现问题，网络中断了；会不会导致数据库和文件对不上，怎么解决的？

### 如何做token验证？

### 网盘项目的网络通信方式

### 有考虑过多线程同时上传一个文件的问题吗？

### md5的算法是自己实现的吗？

### 文件如何和用户绑定？

### 连接使用的是长连接还是短链接？

### 长连接socket的参数是怎么设置的？

### 项目为什么要进行文件去重？

### 线程池是如何实现的？

### 线程池在项目当中是怎么用的，分别有哪些线程，它们是怎么分工的？

### 线程池中的线程数目是否会随并发量动态增加？

### 如何确定线程池中线程的状态？

## 搜索引擎项目

## 可执行文件

### 一个网页的信息是通过什么形式存储的？

---

### Simhash 是什么，怎么使用的，用什么存储的？

1. Simhash是一种用于计算和比较文本相似度的算法
    可以将文本转换为一个固定长度的哈希值, 被广泛应用于 文本去重/搜索引擎 领域

2. 使用步骤 `simhasher.make(_docContent, topN, ul);`

    1. 分词
        将待比较的文本进行分词，通常使用中文分词工具 jieba

    2. 特征提取
        对每个词语或词项计算一个特征值

    3. 权重加权
        对特征值进行加权处理, 加权方法一般基于词语的频率、位置等。

    4. 构建Simhash
        将加权后的特征值进行组合，生成Simhash值。Simhash值通常是一个固定长度的二进制哈希值，例如64位或128位。

    5. 比较
        计算它们的海明距离(Hamming Distance), 汉明距离越小，表示两个文本的相似度越高
        海明距离即为 两个 Simhash 值进行 异或(XOR) 操作后 1 的个数

3. 存储 uint64_t

---

### Simhash 使用的哈希函数

jenkins

---

### 介绍一下倒排索引，余弦相似度算法

1. 倒排索引
    将文档集合中的每个词语映射到包含该词语的文档列表, 以便快速定位包含特定词语的文档
    网页搜索中的词语倒排索引
    倒排索引库储存 {词语:{{文章id, W'}, ..., ...}}

2. 余弦相似度
    余弦相似度仅衡量向量之间的**方向相似度**, 而不考虑向量之间的距离
    即两个向量夹角的余弦值, 范围 [-1, 1];
    -1 表示两个向量方向相反, 方向相似度最小;
    1 表示两个向量方向相同, 方向相似度最大;
    0 表示两个向量正交, 即互相独立;
    ![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202311222216085.png)

---

### TF-IDF(Term Frequency-Inverse Document Frequency)

1. 用于评估 词语 在文档集合中重要程度的指标
    词频(TF) 和 逆文档频率(IDF) 两个因素, 用于衡量一个词语在文档中的相对重要程度

2. TF(词频) 表示一个词语在文档中出现的频率
    可以先计算词语在文档中出现的次数, 然后进行归一化处理
    也可以直接使用相对词频, 即词语出现次数除以文档中总词语数

3. IDF(逆文档频率) 衡量了一个词语在整个文档集合中的稀有程度
    它通过计算一个词语在文档集合中出现的文档频率的逆数来获得
    IDF = log(N/(DF+1))

4. TF-IDF
    w = TF \* IDF = TF \* log(N/(DF+1));

---

### 任务队列是怎么实现的，阻塞还是非阻塞？

### 负载均衡怎么做的？

### 什么是最短编辑距离，给你几个例子说说他们的最短编辑距离

最短编辑距离(Shortest Edit Distance) 是衡量两个字符串之间相似度的度量标准
它定义为将一个字符串转换为另一个字符串所需的最少编辑操作次数, 允许的编辑操作包括 **插入**/**删除**/**替换**

```c++
// 动态规划
class Solution {
public:
    int minDistance(string word1, string word2) {
        vector<vector<int>> dp(word1.size() + 1, vector<int>(word2.size() + 1, 0));
        for (int i = 0; i <= word1.size(); i++) dp[i][0] = i;
        for (int j = 0; j <= word2.size(); j++) dp[0][j] = j;
        for (int i = 1; i <= word1.size(); i++) {
            for (int j = 1; j <= word2.size(); j++) {
                if (word1[i - 1] == word2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1];
                }
                else {
                    // 替换 / 删除 word1 / 删除 word2
                    dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;
                }
            }
        }
        return dp[word1.size()][word2.size()];
    }
};
```

### 双缓存轮换是怎么做到的，为什么不使用单缓存加锁？

### LRU算法的原理

### 为什么使用LRU算法，还可以选用什么算法？

### 如何加快搜索速度？

### 缓存和数据库如何实现同步操作

### 项目当中的任务队列具体会有哪些任务？

### 搜索引擎项目用了几个进程几个线程池

---

## Http 项目

---

### 介绍一下这个 workflow 编程范式是什么，怎么用的，以及这个框架能对项目起到什么作用？

---

### 有没有用什么二进制通信协议？

protobuf

---

## 开放性问题

### 离职原因

### 大学学过的和软件开发相关的课程？

### 互联网以后的发展

### 有没有看过开源代码和较深的数据结构？

### 给一个尺子，算一栋楼的高度

### 1000支试管，只有一支有毒，怎么用最少的小白鼠检测出有毒？

### 最佩服的人

### 最大的挫折

### 有没有研究新技术

### 毕业论文是什么？你对毕业论文的理解(这个论文的方向为什么吸引你)？

### 你有什么想问的？

### C++了解到什么程度？

### 你之前工作小组怎么构成的？都干了多久？

### 你之前公司是做什么业务的？

### 之前工作累吗？工作时间之类的问题？

### 你过去的工资怎么构成的？

### 了解过我们公司吗？

### 了解QT客户端开发吗？

### 是否对OpenGL有了解？

### 工作压力主要来自哪儿？

### 工作过程中最难忘的一件事儿？

### 未来的职业规划？

### 进入公司后，一年的规划

### 项目需求怎么来的？

### 项目怎么展开的？

### 代码怎么测试的？

### 测试用例自己写吗？

### 多久做一个项目？

### 修复bug的过程？讲一个具体修复过的bug？怎么发现的bug？

### 如果某个模块运行过程中内存增长速度过快，应该怎么处理？

### 处理过的难度最高或挑战性最大的问题？

### 有没有什么学习计划？使用这种学习计划多长时间了，会不会有完不成的情况？

### 旁边有人不停打扰，怎么办？

### 你在找工作时更看中什么？

### 接受加班么？

### 期望薪资多少呢？

### 对这个行业有什么看法

### C++ primer中令你印象最深刻的是什么？

### 是否会用UML?

### 上一家公司的总体规模

### 上一家公司是什么样的开发，是敏捷式还是瀑布式还是别的类型的开发模式

### 如何验证自己所写代码的质量？

### 在以前的工作当中是否参与到某几款软件或者系统的设计工作/软件设计？

## 项目相关

### 介绍一下你的项目

### 整个项目做了多长时间？项目多少个人？

### 你的项目瓶颈在哪？怎么优化的？性能提升了多少？

### 使用过什么测试性能的工具？

### 项目中遇到的最大的问题是什么？

### 你们系统的性能如何？系统挂掉了怎么办？系统挂掉后，会不会有断流出现？

### 项目组人数，担任的角色，工作的流程，如何提交给测试？

### 如果需要在已有项目上新增功能，需要考虑哪些问题？

### 项目有没有做过压测，怎么做的？

### 常用的云服务有用过吗？它的原理是？

### 私有云有没有用到集群
