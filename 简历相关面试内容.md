# 简历相关面试内容

## C++

### C++ 流程控制

1. 选择
    `if...else if...else`
2. 循环
    `while...` / `do...while` / `for...`
3. 跳转
    `break` / `continue` / `goto` / `return`

### 指针问题

1. 野指针
    野指针是一个未被初始化的指针;

2. 悬空指针
    悬空指针指 指针指向的内存空间已被释放或不再有效;

3. 解决方案
    1. 定义指针时便进行初始化, 无法确定值 可以先初始化为 nullptr
    2. 访问 指针指向的值时, 先判断指针是否为空
    3. 删除 指针指向的空间后将指针置为 nullptr
    4. 使用 智能指针

### 指针 和 引用 的区别/联系

1. 联系:
    1. 引用和指针都是用来 **间接** 访问变量
    2. 引用的底层是使用指针完成的, 可以把引用看成一个 受限制 的指针

2. 区别：
    1. 引用不能单独存在，但是指针可以单独存在(野指针问题)
    2. 引用必须初始化，指针可以不初始化：
    3. 引用一经绑定便不能修改绑定，但是指针可以随意修改指向，非常灵活(灵活意味着强大，也意味着容易出错一引用的设计初衷就是希望程序员少用指针)
    4. 引用的地址即变量本身的地址，筒单理解为引用不额外占据内存;
        而指针在内存中占据的空间是存储地址所需要的字节数

### 面向对象与面向过程区别

### 面向对象特点

1. 封装
    将数据和方法 捆绑在一起, 形成一个类;
    该类会提供对数据的访问控制, 但是对外会隐藏类内部实现细节, 由此实现数据的 **安全性** 和 **可维护性**;
    类的设计原则中, 开闭原则要求 **对拓展开放, 对修改关闭**, 需要借助 抽象类 来实现

2. 继承
    1. 通过已有类创建新类即为继承
    2. 通过继承, 派生类 可以继承 基类 的属性和方法, 并且可以在此基础上进行**扩展或修改**, 如 重写虚函数
    3. 可以减少代码重复, 提高代码的复用率
    4. 但是当基类中的 **虚函数** 或 **类本身** 被 `final` 关键字修饰, 则修饰的类不能继承, 修饰的虚函数不能重写

3. 多态
    1. 多态是指相同的接口(方法) 可以在不同的对象上具有不同的实现
    2. 允许使用基类的指针或引用来调用派生类的方法, 在运行时根据对象的实际类型来确定调用的函数
    3. 多态性提高了代码的 **灵活性** 和 **可扩展性**, 使得可以通过统一的接口处理不同类型的对象

    分类: 静态多态/动态多态/参数多态

### 泛型编程

1. 即 **函数/类模板**
2. 函数模板允许定义通用的函数, 该函数可以接受不同的参数
3. 编译器进行**编译**时可以根据参数类型生成对应的 函数实例

### (动态)多态实现原理

1. 基类中若定义了虚函数, 则在基类函数入口地址处会存在一个**虚函数指针**, 该指针指向**虚函数表**, 虚函数表中储存虚函数的入口地址;
2. 当派生类继承了基类, 并且重写虚函数, 则派生类的虚函数入口地址会覆盖虚函数表中的基类的虚函数入口地址;
3. 当使用基类指针指向派生类对象 或者 使用基类引用绑定派生类对象时 会根据虚函数指针去寻找虚表, 继而找到虚函数入口地址;
4. 而此时找到的其实是派生类对象的虚函数

### 重载/重定义/重写 这三者有什么区别？

1. 重载(overload)
    发生在同一个作用域中, 函数名称相同, 而参数列表不同 (即类型、顺序、个数不同)

2. 重定义/隐藏(oversee)
    1. 发生在基类派生类之间, **函数名称相同**, 可以作用于基类虚函数, 也可以作用于基类的非虚函数;

    2. 但是作用于基类非虚函数时不会触发多态

3. 重写/覆盖(override)

    1. 发生在基类派生类之间, 基类与派生类中同时定义相同的虚函数(**函数名/参数/返回值**)

    2. 只能作用于基类的虚函数

    3. 覆盖的是虚函数表中的入口地址, 并不是覆盖函数本身

### C++中有哪些智能指针，它们有什么异同？

定义于头文件 <memory> 中, 其中 `auto_ptr` 属于 C++98, `unique_ptr / shared_ptr / weak_ptr` 属于 C++11

1. `std::auto_ptr` (C++98)

    代码层面存在 bug, 即允许拷贝构造, 但是会发生**所有权的转移**

    ```c++
    auto_ptr<int> ap(new int(10));

    // 将 ap 托管的堆空间 new int(10) 转接给了ap2, 然后将 ap 的 数据成员的指针置空
    // 再对 *ap.get(), 会发生 bug
    auto_ptr<int> ap2(ap);
    ```

2. `std::unique_ptr`

    1. **<mark>独享所有权</mark>** 的智能指针
    2. <mark>不允许 拷贝/赋值</mark> ------> 对象语义
    3. 具备 移动语义 (移动复制/赋值)
    4. 可以作为容器元素  
        将右值转递到容器中, 调用 移动复制  
        不能传左值, 因为 拷贝构造 delete
    5. 删除器 (模板参数中声明)

        ```c++
        // 删除器, operator() 内默认 delete ptr / delete [] ptr
        struct FILECloser {
            void operator()(FILE* ptr) const {
                if (ptr) {
                    fclose(ptr):
                }
            }
        }     

        unique_ptr<FILE, FILECloser> up(fopen(..., ...));
        ```

3. `std::shared_ptr`

    1. **共享所有权** 的智能指针 ----> 通过引用计数表明资源被几个指针共享, 计数减为 0 时, 自动释放内存空间
    2. 可以 复制 / 赋值 -------> 值语义
    3. 支持 移动复制 / 赋值
    4. 可以作为 容器元素  
        既可以传左值, 也可以传右值
    5. <mark>循环引用( **重要** )</mark>  
        存在内存泄漏  
        解决方案: 使用 **弱引用** 智能指针, 不会增加引用计数
        ![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202309221613008.png)
        ![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202309221633067.png)

    6. 删除器 (构造函数中声明)

        ```c++
        // 删除器, operator() 内默认 delete ptr / delete [] ptr
        struct FILECloser {
            void operator()(FILE* ptr) const {
                if (ptr) {
                    fclose(ptr):
                }
            }
        }     

        // 删除器位于 构造函数中, 左右值均可
        // 1. 此处 fc 不能加 括号
        FILECloser fc;
        shared_ptr<FILE> sp(fopen(xxx, xxx)i, fc);
        // 2.  
        shared_ptr<FILE> sp(fopen(xxx, xxx)i, FILECloser());
        ```

4. `std::weak_ptr`

    1. **弱引用** 智能指针, 不会使 引用计数 ++
    2. 不能直接托管关联的堆空间 (不能直接传递一个 **裸指针** 进行构造)
    3. 不能 解引用 / 箭头
    4. 判断资源是否以回收
        1. `use_count`
        2. `expired()`
        3. `lock()`

    ```c++
    shared_ptr sp(new int(10));
    weak_ptr<int> wp;
    wp = sp;

    // 获取引用计数
    sp.use_count();
    wp.use_count();

    // 检查对象是否已经销毁, 返回 bool
    wp.expired();

    // 将 weak_ptr 提升为 shared_ptr; sp2 存在则未被销毁
    shared_ptr<int> sp2 = wp.lock();
    ```

---

### shared_ptr使用的注意事项？

1. `shared_ptr` 特有问题

    **循环引用** 导致内存泄漏, 可以使用 `weak_ptr` 解决

2. 智能指针通用问题

    使用了不同的智能指针托管同一片堆空间  

---

### weak_ptr 如何解决 shared_ptr 的循环引用问题？

1. `shared_ptr` 是强引用的智能指针, 会使引用计数进行累加; 但是 `weak_ptr` 是 **弱引用** 的智能指针, 不会使引用计数进行累加

2. 因此将资源内部的 智能指针改为 `weak_ptr`, 则循环引用的两个资源的引用计数并不会增加, 还是 1, 当 `shared_ptr` 销毁时资源引用计数变为 0, 便会自动释放, 不会产生内存泄漏

### lambda 函数

1. 格式
    `[]()->xx{}`
    1. `[]` 为捕获列表, 捕获可以按值捕获/按引用捕获/混合捕获;
        按值捕获 `=` / 按引用捕获 `&` / 混合捕获 `[=, xx, xx]` `[&, xx, xx]`
    2. `()` 参数列表
    3. `xx` 为返回值类型, 可省略;
    4. `{}` 为函数体

2. 提供了一种便捷的方式来编写简洁、**内联** 的函数代码

### std::function

头文件<functional>

1. `std::function` 是一个函数包装器, 可以包装可调用实体, 如普通函数/函数对象/lamda表达式等

### 移动语义

1. 移动语义是指将一块内存单元从一个对象转移到另一个对象

2. 分类
    ![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202311232236103.png)
    表达式分为 泛左值 + 右值;
    泛左值又分为 左值 + 将亡值, 具名;
    右值又分为 将亡值 + 纯右值, 可移动;
    即 左值:具名不可移动; 将亡值:具名可移动; 纯右值:不具名可移动;

3. 泛左值来源
    1. 左值经 `std:move` 转换
    2. 将纯右值作为返回值时, C++17编译器会将其优化为将亡值

### STL包括哪些内容？

1. 容器
2. 迭代器
3. 算法
4. 适配器
5. 函数对象
6. 空间配置器

### vector 底层实现

1. 由 3 个指针构成
2. `_start` 指向当前数组中第一个元素存放的位置
3. `_finish` 指向当前数组中最后一个元素存放的下一个位置
4. `_end_of_storage` 指向当前容器存放的最后一个元素的下一个位置
5. vector 中的元素存在 堆上
    ![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/image-20230908175603277.png)

### vector 迭代器失效的情况有哪些？

1. vector 迭代器失效
    1. 概念: 底层发生扩容现象, 而迭代器还指向老的空间, 使用 老的迭代器 去操作 新的空间  
    2. 解决方案: vector 每次插入前重新置位(获取) 迭代器
    3. insert 扩容策略
        size() = m, capacity() = n, 待插入的元素的个数 t
        1. t < n - m; 此时就不会扩容
        2. n - m < t < m; 会按照 2*m 进行扩容
        3. n - m < t, m < t; 会按照 m+t 进行扩容

        push_back 每次插入元素的个数都是固定的 1, 所以按照 两倍 进行扩容肯定容器是足够的;  
        但是 insert 进行插入元素的时候, 元素的个数是不一定的, 所以不能按照某个固定值的两倍进行扩容.

2. 解决方案
    1. 进行修改操作后, 重新获取新的迭代器
    2. 对于vector, 可以使用索引代替迭代器进行访问
    3. 如果需要在循环中进行修改操作, 并且需要同时使用迭代器, 可以考虑使用 **迭代器的返回值** 来更新迭代器
        如 insert()、erase() 会返回指向被插入或删除元素位置的迭代器

### 释放 vector 的内存的处理方式

1. `clear()`
    将容器中的元素清空, 并且保留容器的容量不变; 可以释放元素占用的内存，保留容量可以避免重新分配内存的开销, 以备后续再次存储元素使用

2. `shrink_to_fit()`
    可以将容器容量减少至当前大小, 释放多余内存

3. 析构函数

### clear 和 erase 的区别？

1. `clear()` 用于清空容器中的所有元素, 将容器恢复为空, 不释放内存
    `erase()` 用于删除容器中的一个或多个元素, 可以通过指定位置或迭代器来删除, 会使得后续元素向前移动, 容器大小减少
2. `clear()` 不会使迭代器失效, 而 `erase()` 可能会使迭代器失效
3. `erase()` 返回指向待删除元素下一个元素的迭代器

### deque

1. 特点:
    1. 逻辑上连续, 物理上不连续
    2. 片段之间是依靠中控器数组进行控制的
        ![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202309261033477.png)  
        ![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202309261057206.png)
        ![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202309261104426.png)
        ![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202311241024104.png)

### map 和 unordered_map 的区别

1. 底层实现
    map 底层实现为红黑树, unordered_map 底层实现为 hash

2. 有序性
    map 是一个有序容器, 它根据**键值**进行排序;
    unordered_map 是一个无序容器

3. 查找操作
    1. map 查找的时间复杂度为 O(log n)的元素数量。且提供额外操作, 如 `lower_bound()` 和 `upper_bound()`
        `lower_bound` 返回首个 >= 给定值的迭代器
        `upper_bound` 返回首个 > 给定值的迭代器
        ![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202311241101045.png)
    2. unordered_map 查找的时间复杂度为 O(1)

4. 迭代器稳定性：

    map 的迭代器在插入和删除操作后仍然有效, 不会失效
    unordered_map 的插入和删除操作可能会导致哈希表的重新哈希, 从而使得迭代器失效

### 空间配置器的底层实现

特点：将空间的申请与对象的构建以及空间回收与对象的销毁严格的分开了

1. 一级空间配置器
    \> 128B
    分配大块内存, `malloc()` / `free`

2. 二级空间配置器
    <= 128B; 16 个自由链表 + 内存池

    1. 对于小片空间, 可以防止频繁进行空间申请的问题 (内存碎片问题)

    2. 为了防止频繁在内核态与用户态之间进行切换导致的系统开销

        ![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202310032237118.png)

### string 的底层实现

1. 深拷贝

2. 写时复制 (COW-CopyOnWrite)
    引用计数  
    ![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202309151100067.png)

3. 短字符串优化(SSO)
    string 会在栈上分配一部分内存作为默认容量
    当字符串长度小于等于默认容量时, 字符串会直接存储在对象内部的内存空间中;
    当需要存储的字符串长度超过默认容量时, 会自动进行堆内存分配, 并将字符串存储在堆上分配的内存中
    1. 概述  
        字符串的长度小于等于15个字节时, buffer直接存放整个字符串;  
        当字符串长度大于15个字节时, buffer存放的是一个指针, 指向堆空间的区域;  
        **注意:** 对象地址 指向低地址, 内容地址 指向高地址
        ![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202309151635349.png)

    2. 当在栈上创建字符串时
        1. len <= 15, str内容分布在栈上;
        2. len > 15, str内容分布在堆上;  

## 数据库

### 数据库事务有哪些特性？(ACID)

1. 原子性(Atomicity)  
    事务中的操作要么全部发生, 要么全部都不发生

2. 一致性(Consistency)
    事务执行前后, 数据的完整性保持一致 且 事务执行前后数据的总和不变

3. 隔离性(Isolation)
    1. 一个事务的执行不能被其他事务干扰, 即一个事务内部的操作 及 使用的数据 对并发的其他事务是 隔离的, 并发执行的各个事务之间不能互相干扰

    2. 两个事务之间是没有交集的

    3. 隔离性与隔离级别是有关的

4. 持久性(Durability)
    事务一旦提交, 对数据库中数据的改变就是永久性的, 直到其他事务将该数据发生修改

### 并发 4 问题

1. 脏写
    多个事务并发写入同一数据时, 先执行的事务所写数据 被后写的数据覆盖

2. 脏读
    一个事务 写入数据 且 未提交/终止, 另一事务便读取到了 写入的数据

3. 不可重复读
    一个事务 对同一数据项进行多次读取, 但是在两次读取间 另一事务修改了该数据项 并 进行了提交, 则 后一次读取到修改, 导致两次读取 信息不一致

4. 幻读
    一个事务 进行两次统计, 但是在两次统计期间 另一事务 添加了新的数据项 并且进行了提交, 则 后一次统计到修改, 导致两次统计信息不一致

### 事务的隔离级别有多少种，分别是什么？

![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202310162058411.png)

1. 读未提交
2. 读已提交
3. 可重复读
4. 可串行化

### MySQL 索引使用 B+ 树, 与 B 树区别

1. B 树
    1. 多叉树, 每个大节点中可以存放多条数据(小节点), 每个小节点会存储 **索引信息/数据信息/指向下一个节点的指针**, 相比于 二叉树, 可以降低树的高度, 进而较低磁盘 IO 的次数, 减少时间消耗;
    2. 但是 因为 每个而小节点还需要存放**数据信息**, 导致 每个大节点中存放的小节点个数有限

2. B+ 树
    1. 除叶节点外每个节点只会存储 **索引/指向下一个节点的指针**, 相比于 B 树, 每个大节点中存放的小节点个数更多, 树的高度会更低, IO 次数更少;
    2. 所有的 叶子节点 存储完整的一份 **索引信息(Key) 以及 对应的data信息**;
    3. 每一个父节点 都出现在子节点中, 是子节点的最大或者最小的元素;
    4. 每个叶子节点都有一个指针, 指向下一个节点, 形成一个链表

### B+ 树优势

1. 范围查询效率高
    B+ 树的叶子节点形成了一个有序链表, 可以方便地进行范围查询
    而 B 树和红黑树则需要通过中序遍历或其他方式来实现范围查询, 效率较低

2. 索引占用空间更小
    B+ 树的内部节点只存储键值信息, 而不存储具体的数据, 只有叶子节点包含了完整的数据行
    B 树和红黑树的每个节点都需要存储键值和数据信息, 导致索引占用的空间更大

3. 适合磁盘存储
    B+ 树的节点通常比较大, 可以容纳更多的键值, 减少了树的层数, 适合在磁盘上存储
    B 树和红黑树的节点较小, 树的高度较高, 在磁盘存储时需要更多的 IO 操作

### 共享锁与独占锁

1. 共享锁 (Shared Lock)
    **读锁**, 多个事务可以同时持有共享锁, 用于对同一资源进行读取操作, 彼此之间不会产生冲突
    共享锁阻止其他事务获取独占锁(写锁), 但不阻止其他事务获取共享锁

2. 独占锁 (Exclusive Lock)
    **写锁**, 只有一个事务可以持有独占锁, 用于对资源进行写入或修改操作
    独占锁与其他任何锁(共享锁或独占锁)都是互斥的

### 乐观锁和悲观锁

1. 悲观锁 (Pessimistic Locking)
    悲观锁认为在事务处理过程中会发生冲突, 因此在**访问数据之前**就会将其锁定, 阻止其他事务对数据进行修改
    适用于对数据进行长时间的修改操作, 适合于**写多读少**的场景
    悲观锁常用的实现方式是通过 **行级锁或表级锁** 来实现

2. 乐观锁 (Optimistic Locking)
    乐观锁认为在事务处理过程中不会发生冲突, 因此在**事务提交时**才会检查是否发生了冲突
    如果检测到冲突, 如数据已被其他事务修改, 则需要**回滚事务或重新尝试**
    乐观锁适用于**读多写少**的场景, 可以提高并发性能
    乐观锁通常使用**版本号或时间戳**等方式来实现, 每个数据项都有一个对应的版本号或时间戳, 事务在修改数据时需要比较版本号或时间戳, 判断是否发生了冲突

### Redis持久化机制

1. RDB快照 (Redis Database)
    在指定的时间间隔内将**Redis数据集**的状态保存到硬盘上的一个**二进制文件**中
    RDB持久化通过 `fork()` 子进程来完成持久化过程, 父进程继续处理客户端请求, 因此在持久化期间不会阻塞客户端操作
    RDB持久化适用于周期性备份数据，以及在Redis重新启动时快速加载大量数据的场景

2. AOF日志 (Append Only File)
    AOF持久化记录了Redis服务器接收到的所有**写操作命令**, 以追加的方式将命令写入到一个**文本文件**中
    AOF持久化适用于需要更精确的数据恢复, 并且可以提供更好的数据安全性保证的场景

3. 混合持久化

### 解释一下Redis缓存雪崩，缓存击穿，缓存穿透？

1. 缓存雪崩
    指在某个时间点, 缓存中大量缓存数据同时失效或过期, 导致大量的请求直接访问后端数据库, 从而造成数据库压力过大
    1. 将缓存失效时间分散开, 比如在原有的失效时间基础上增加一个随机值
    2. 不设置缓存的过期时间, 有更新操作时就把热点的缓存全部更新

2. 缓存击穿
    热点数据从缓存内失效时, 大量访问同时请求这个数据, 就会将查询下沉到数据库层, 导致数据库压力过大
    1. 延长热点key的过期时间或者设置永不过期
    2. 利用互斥锁保证同一时刻只有一个客户端可以查询底层数据库的这个数据

3. 缓存穿**透**
    要查询的数据不存在, 缓存无法命中所以需要查询完数据库, 但是数据是不存在的, 此时数据库肯定会返回空, 也就不会记录到缓存中, 这样每次对该数据的查询都会穿过缓存去查询一次数据库

## 设计模式

### 设计原则

1. 单一职责原则
    类的职责要单一, 不能将太多的职责放在一个类中

2. 开闭原则
    软件实体**对扩展开放**的, 但**对修改关闭**的, 即在不修改一个软件的基础上去扩展其功能

3. 里氏替换
    在软件系统中, 一个可以接受基类对象的地方必然可以接收一个派生类对象

4. 依赖倒置原则
    要针对抽象编程, 而不是针对具体编程

5. 接口隔离原则
    使用多个专门的接口来取代一个统一的接口

6. 迪米特法则
    一个软件实体对其他实体的引用越少越好, 或者说如果两个类彼此直接通信, 那么这两个类就不应当发生直接相互作用, 而是通过引入一个第三者发生间接交互

7. 合成复用原则
    在系统中应该尽量多使用组合/聚合/关联关系, 尽量少使用甚至不使用继承关系

### 如何使用单例模式，有什么注意事项？

1. 构造 / 析构函数 私有; 拷贝构造 / 赋值运算符 `delete`;
2. 局部静态变量实现单例模式 (C++11 线程安全)

```c++
class Single {
public:
    // 获取单实例对象
    static Single& GetInstance();

private:
    // 构造/析构 私有
    Single() {}
    ~Single() {}

    // 拷贝构造/赋值运算 delete
    Single(const Single &single) = delete;
    Single &operator=(const Single &single) = delete;
};

Single& Single::GetInstance() {
    static Single single;
    return single;
}
```

## 问题汇总

1. 引用到底会不会占用额外的存储空间, 哪怕极小的额外空间
2. 