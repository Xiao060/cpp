# 多态

## 概述

1. 概念
    不同对象面对同一指令产生不同行为

2. 分类
    1. 静态多态: 编译时可以确定  
        函数重载 / 运算符重载 / 函数模板 ----> 静态联编
    2. 动态多态: 运行时可以确定  
        虚函数 (virtual)

3. 动态多态(虚函数指针)
    ![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202309191113631.png)

## 虚函数原理

![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202309191111520.png)

1. 基类 中定义 虚函数时, 内存结构中会 存在一个 vfptr(虚函数指针), 指向虚函数表(虚表), 虚表中记录的是虚函数的 入口地址  

2. 派生类 中重定义 该函数时, 发生覆盖(override), 即覆盖了虚表中虚函数的入口地址  

3. 当使用 基类指针 指向 派生类对象时, 能够操纵的只有 基类部分(包含 vfptr); 当使用指针调用 该函数时, 会通过 vfptr 去 虚表 查找

## 动态多态（虚函数机制）被激活的条件

1. 基类中要 定义虚函数
2. 派生类中要 覆盖虚函数 (覆盖的是虚函数表中的地址信息)
3. 要创建 派生类对象
4. 基类 **指针** 指向派生类对象 (基类 **引用** 绑定派生类对象)
5. 通过基类指针(引用) 调用虚函数

## virtual关键字的含义 (面试常考)

存在、间接、共享

1. 虚函数是 存在的
2. 通过 间接 的方式去访问
3. 通过基类的指针访问到派生类的函数，基类的指针 共享 了派生类的方法

## 虚函数表

1. 虚函数表存在位置  
    编译完成时，虚表应该已经存在; 在使用的过程中，虚函数表不应该被修改掉 (如果能修改，将会找不到对应的虚函数), 故应该存在 **只读段** , 具体位置不同厂家有不同实现
2. 一个类中虚函数表有几张  
    1. 一个类可以 没有 虚函数表
    2. 可以有 一张 虚函数表(如果一个类中定义了多个虚函数，也是把这些虚函数的入口地址存在一张虚函数表中)
    3. 可以有 多张 虚函数表
