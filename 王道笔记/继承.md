## 继承

### 概述
1. 继承的局限(不能继承)
   1. 构造 / 析构函数
   2. 拷贝构造
   3. 用户重载的 `operator new` / `delete` 运算符
   4. 用户重载的 `operator=` 运算符
   5. 友元关系

2. 派生(继承)方式

   1. `public` 公有继承 (接口继承: 派生类对象可以访问基类接口)
   2. `protected` 保护继承 (实现继承)
   3. `private` 私有继承 (实现继承)
    ![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202309151721192.png)

3. 步骤
   1. 吸收基类的成员
   2. 添加自己新的成员 (非必需)  
    派生类可以不添加新的成员、不实现新的功能, 这样的派生类称为空派生类, 其目的是在一些特定场景下建立继承关系, 为将来的拓展留出空间
   3. 改造基类的成员 (非必需)  
      1. 若 派生类中 存在与 基类中 <mark>同名</mark> 的数据成员, 派生类对象 直接访问得到的是 派生类成员; 若想访问基类成员, 则需要加 `xxx.类名::xxx` (注意不是覆盖)
      2. 基类成员函数的 隐藏(oversee)   
         派生类定义了与基类中成员函数同名的成员函数, 即使参数列表不同，也只能访问到派生类的成员函数;  
         若没有定义同名函数, 则 可访问到 基类的成员函数  
         与函数重载是有区别的，函数重载是在同一个类作用域中，函数的隐藏是发生在基类派生类之间 (两个类作用域)
    

4. 创建 派生类对象 时调用 基类构造 的机制
   1. 先调用派生类构造函数, 再调用基类构造函数; 先构造基类部分, 再构造派生类部分
   2. 派生类的构造函数若没有显式调用基类的构造函数, 则创建派生类对象时会自动调用 无参构造; 若基类无 无参构造, 则派生类创建失败
   3. 当派生类对象调用基类构造时, 希望使用非默认的基类构造函数, 必须显式地在初始化列表中写出
   
5. 析构函数
   1. 先执行 派生类对象 的析构函数
   2. 执行完之后执行 成员子对象 的析构函数
   3. 最后执行 基类子对象 的析构函数 
    ![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202309181130840.png)

6. 总结
   1. 派生类在类之外对于基类成员的访问，具有什么样的限制？  
   只有公有继承自基类的公有成员，可以通过派生类对象直接访问，其他情况一律都不可以进行访问 

   2. 派生类在类内部对于基类成员的访问，具有什么样的限制？  
   对于基类的私有成员，不管以哪种方式继承，在派生类内部都不能访问;  
   对于基类的非私有成员，不管以愿种方式继承，在派生类内部都可以访问;

   3. 保护继承和私有继承的区别？  
   如果继承层次中都采用的是保护继承，任意层次都可以访问顶层基类的非私有成员;  
   但如果采用私有继承之后，这种特性会被打断.

7. 多重继承
   1. 多重继承每个类都要写明 继承方式, 否则默认为 private 私有继承
   2. 
