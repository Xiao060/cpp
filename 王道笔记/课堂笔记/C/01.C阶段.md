# C

## 编译与链接

1. 预处理
    - **`#include`**  -------------\头文件包含 (把头文件中的内容复制到指令所在的位置)
    - **`#define N 5`**  -----------\宏定义 (简单的文本替换)
    - **`#define FOO(x) (1 + (x) * (x))`**  -------------\宏函数(文本替换: 用“实参”替换“形参”)
        - 宏函数注意事项:
            - 括号紧贴名称
            - 参数用括号括起来
            - 整个表达式也应该括起来
        - 宏函数优点
            - 避免函数调用的开销
            - 不限制参数类型, 提供宏编程能力
        - 宏函数应用场景
            - 替换简短的, 反复调用的函数
2. 编译: 把预处理后的文件 翻译成 ==汇编==代码 (==.i== ----\==.s==)
3. 汇编: 把编译后的汇编代码 翻译成 ==机器==代码 (==.s== -----\==.o==)
4. 链接: 把目标文件 与 库文件 链接到一起生成 ==可执行==程序
    <img src="https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/20230716113139.png" alt="" width="689" height="302" class="jop-noMdConv">

* * *

## 数据类型

- 学习内容
  - 值的范围
    - 内存空间(字节长度)
    - 编码方式
  - 值的操作
  - 字面值的书写
  - 值的读写方式

1. 整数

    - 值的范围
        - 内存空间
            - short ------------------2bits --------32768 ~ 32767
            - unsigned short --------2bits -------65535
            - int
            - unsigned int -----------4bits -------约43亿
        - 编码方式
            - 无符号整数 -------\原码
            - 有符号整数 -------\补码
                - b<sub>n-1</sub>b<sub>n-2</sub... b<sub>3</sub>b<sub>2</sub>b<sub>1</sub>  = ==-b<sub>n-1</sub\* 2<sup>n-1</sup>== \+ ... +b<sub>1</sub\* 2<sup>0</sup>
                - ==x + (-x) = 1000...000== (n个0)
                - ==x  + (~x) = 111...111  = -1== (n个1)
    - 字面值的书写
        - 编码方式
            - 二进制 ---------\以 ==0b== 开头
            - 十进制
            - 八进制 ---------\以 ==0== 开头
            - 十六进制 -------\以 ==0x== 开头, 大小写不敏感
        - 类型
            - int ----------------默认
            - long --------------后面加 ==L==
            - long long ---------后面加 ==LL==
            - unsigned ---------后面加 ==U==
    - 值的读写方式
        - 无符号
            - 十进制 ---------------------\==%u==
            - 八进制 (octor) --------------==%o==
            - 十六进制 (hexdecimal) -----==%x==
        - 有符号
            - 十进制 (decimal) -----------==%d==
        - 其他
            - short -------------==h==
            - long --------------==l==
            - long long ---------==ll==
2. 浮点数

    - 操作 \-\-\-\-\-\-\- \不能 取余 / 位运算
    - 字面值的书写
        - 包含 小数点 / 指数
        - 类型
            - float ----------------末尾加 ==F==
            - double -------------默认
            - long double --------末尾加 ==L==
    - 读写方式
        - float -------------------%f
        - double -----------------%lf
        - long double ------------==%Lf==
3. 字符类型

    - 操作
        - 整数操作
        - 字符分类函数 ------------\**==ctype.h==**
        - 大小写转换函数 ---------\**==ctype.h==**
            - **`int tolower(int c);`**
            - **`int toupper(int x);`**
    - 字面值的书写
        - ASCII 编码
            - 十进制
                - =='\\0' = 0==
                - ==' '  = 32==
                - =='0' = 48==
                - =='A' = 65==
                - =='a' = 97==
            - 八进制 \-\-\-\-\-\-\-\-\-\-\==== \+ 最多 ==3== 位八进制数字 --------\例: \\333
            - 十六进制 --------\==\\x== \+ 十六进制数字
        - 转义序列
            - ==\\n==
            - ==\\t==
            - \\v
            - ====
            - ==\\'==
            - ==\\"==
    - 值的读写方式
        - scanf( ) ------------读取字符不会跳过前面的空白字符, 需要在 %c 前加一个 ==空格==
        - ==getchar( )== --------常用于清空输入缓冲区的剩余字符 ---------\while (getchar( ) != '\\n');
        - ==putchar( )==
4. 布尔类型

    - ==stdbool.h== -------\==true== / ==false==
5. 类型转换

    - 隐式类型转换
        - 常见情况
            - 表达式
            - 赋值
            - 函数调用
            - return
        - 转换规则
            - ==整数提升== ----------\低于 int / unsigned int ------>   int / unsigned int
            - int ----long ----long long ----float ----double ----long double
            - 同一转换等级 有符号整数 与 无符号整数 运算 -------------\==int -------unsigned int==
    - 显示类型转换
        - 常见情况
            - 计算浮点数小数部分
            - 解释说明
            - 整数除法 ------------\double
            - 避免溢出 ------------\int + int --------long
6. 别名

    - 格式 ----------\**`typedef 类型 别名;`**
    - 优点
        - 增加可读性
        - 增加可移植性
7. sizeof( )

    - 注意事项
        - 返回值为 size_t 类型, 即 int
        - 后面接 类型 / 表达式 必须加括号
        - 后面接 变量 / 常量 不需加括号
    - 使用方式
        - #define SIZE(a) (sizeof(a) / sizeof(a\[0)) --------------常用来计算数组长度

* * *

## 输入 / 输出

![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/20230723212400.png)

1. ==printf==(格式字符串, 表达式1, 表达式2, ...)
    - 普通字符 ------\原样显示
        - 转换说明 ------\替换为后面的表达式
            - 作用:
                - 占位符
                - 控制输出格式 (m.p / -m.p)
                - 将其他类型的数据  --\字符数据 (X)
        - 格式: -------\==%m.pX==
            - m ------最小字段宽度(minimum field width), 即字符占据的最小位数; 为==正== 右对齐, 为==负== 左对齐
            - p -------精度(precision)
                - 整数 ----\字符显示的最小位数, 不够在前面加 0
                - 小数 ----\小数点后保留的位数, ==默认 6==
            - X
                - %d --------十进制整数
                - %f  --------定点十进制浮点数
2. ==scanf==(格式串, 表达式1, 表达式2, ...) ------->
    - 本质 ------\==模式匹配函数==, 匹配不成功会立即返回 -------\因此读取数据失败时, 不要忘记清空输入缓冲区的剩余字符
    - 匹配规则
        - 普通字符
            - 空白字符 ------\匹配任意多个空白字符(空格 / 水平制表符 / 垂直制表符 / 换页符 / 换行符)
            - 其他字符 ------\精确匹配
        - 转换说明
3. 注意事项
    - printf( ) 函数中 变量前不加 &
    - scanf() 函数中变量名前使用 &
    - scanf() 函数通常不包含其他字符
    - scanf() 读取字符数据时, 可在转换说明前加 ==空格== 用于跳过缓冲区的空白字符
    - scanf() 读取字符数据时不要在最后加换行符
4. 拓展
    - printf( )   --------- 程序 -------stdout
    - fprintf( )  --------- 程序 -------文件
    - sprintf( ) --------- 程序 -------字符数组
    - scanf( )   --------- stdin ------程序
    - fscanf( )  --------- 文件 ------->  程序
    - sscanf( )  ------ 字符数组 -----程序
        - 可用于命令行参数的 类型转换
        - ==**`sscanf(argv[1], "%d", &n)`**==  --------------\从 **argv\[0\]** 读取, 转换为 ==int==(%d), 存储到 变量==n== 中

5. **`总结`**

* * *

## 表达式

1. 运算符优先级

    - 后缀 \+\+ / --
    - 前缀 \+\+ / \-\-  / 正负 \+\- / 逻辑非 ! / 按位非 ! / 取址 & / 解引用 *
    - 算数运算符
    - 移位运算符
    - 关系运算符
    - 按位 & / | / ^
    - 逻辑 && / ||
    - 三目运算符 ?
    - 赋值运算符
    - <img src="https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/20230716195536.png" class="jop-noMdConv" width="684" height="1158" style="zoom: 50%;">
2. 算数运算符

3. 赋值运算符

    - 表达式 v = e 的值为赋值运算后 v 的值
4. 关系运算符

5. 判等运算符

6. 逻辑运算符

7. 位运算符

    - 移位运算符 --------\==<<== / ==>>==

        - 右移规则
            - 无符号 / 非负值 ----->  左侧补 0
            - 负值 ----------------\未定义
            - 左移 / 右移 不会改变变量本身的值
        - 移位性质
            - 左移 j 位 -----* 2<sup>j</sup>
            - 右移 j 位 -----/ 2<sup>j</sup>
    - 按位运算符 --------\==&== / ==|== / ==!== / ==^==

        - 异或性质
            - **`a ^ 0 = a`**
            - **`a ^ a = 0`**
            - **`a ^ b = b ^ a`**------------------------\交换律
            - **`(a ^ b) ^ c = a ^ (b ^ c)`**-------------\结合律
8. **`常见面试题`**
    - **==判断整数是否为奇数==**
        - `x % 2 != 0`
        - `x & 1`
    - **==判断整数是否为 2 的幂==**
        - `(x & (x-1)) == 0`
    - **==找出整数的最低有效位==**
        - `x & (-x)`
    - **==交换 a, b 的值==**
        - `a = a + b; b = a - b; a = a - b;` **-------->** 有可能会溢出
        - `a = a ^ b; b = a ^ b; a = a ^ b;`
    - **==找出数组中只出现一次的元素==**
        - 数组所有元素异或
    - **==找出数组中只出现一次的两个元素==**
        - 所有元素异或
        - 找最低有效位
        - 根据最低有效位的值求两组异或

* * *

## 语句

1. 表达式语句
    - 逗号表达式 ------\expr1, expr2 -------把 expr2 作为整个表达式的值
2. 选择语句
    - 条件表达式 ------\三目运算符
        - 表达式1 ? 表达式2 : 表达式3
    - switch 语句
        - 优点
            - 可读性好
            - 性能优
        - 格式
  
            - ```c
                            switch (控制表达式) {
                                case 常量表达式1:
                                    语句1;
                                    break;
                                case 常量表达式2:
                                    语句2;
                                    break;
                                    ...
                                default:
                                    语句n;
                                    break;
                                }
                ```

        - 注意事项
            - 控制表达式的值必须是 ==int== / ==char== 类型
            - 常量表达式的值必须是 ==int== / ==char== 类型
            - 每组语句最后通常为 ==break;==
            - 若利用 case 穿透, 推荐在语句下写注释 ==/\* break through */==
3. 循环语句
    - for ( ; expr2; ) ---------------省略 expr1 / expr3 时, 相当于 while
    - for (expr1; ; expr3) ----------省略 expr2 时, 相当于无限循环
4. 跳转语句
    - break / continue
        - 可读性好
        - 受限 / 可控
    - goto
        - 只能在函数内跳转
        - 用于退出嵌套循环
        - 用于进行错误处理
5. 复合语句
6. 空语句

* * *

## 随机库

```c
#include<stdlib.h>
#include<time.h>

// 设置随机种子
srand(time(NULL));

// 生成随机数
rand();
```

* * *

## 虚拟内存空间

1. 内核(kernel)

2. 栈(stack) ---------sp 寄存器记录栈顶地址
   - 特点
       - 管理函数调用, 从上向下增长
       - 编译器必须要知道每个栈帧的大小
       - 只能存储固定大小的数据
       - 每个线程有自己独立的栈空间
       - 栈空间大小受限 ------\Linux 主线程 8M, 子线程 2M
       - 栈空间管理非常简单
       - 自动存储期限 / 局部变量

3. 堆(heap)
   - 特点
       - 存储动态大小的数据 (运行时才知道大小的数据)
       - 多个线程共享空间 (函数 申请/释放 空间)
       - 堆空间很大
       - 管理繁琐 ------\malloc / calloc / realloc / free
       - 动态存储期限
   - 存放的数据
       - 大数据 ---------------\大数组 / 字符串
       - 多线程共享数据
       - 动态大小的数据

4. 数据段(data)
   - 静态存储期限 / 全局变量

5. 代码段(code)

   <img src="https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/20230716113525.png" style="zoom:50%;" />

* * *

## 函数

1. 关系
    - ==主调==函数 ----------\==被调==函数
2. 原则
    - 功能单一
    - 实现高效
3. 参数
    - 按值传递
        - 参数列表为==空==: 参数 类型 / 大小不确定
        - 参数为 ==void== : 无参数
    - 数组按指针传递
        - 优点
            - 避免大量复制数据
            - 通过修改形参 ----\改变实参
            - 调用灵活
        - 缺点
            - 丢失了长度信息
            - 模糊了数组与指针的界限
        - 注意事项
            - 若参数为多维数组, 声明参数时不能省略第二个维度的长度, 因为 第二个长度是 数组中每一项的类型
        - 补充
            - **`const char *`** ----\**传入参数, 在函数内部不会修改指针指向的对象**
            - `char *` ----------\**传入传出函数**
4. 静态局部变量
    - ==static==
    - ==**static 修饰函数 ------------函数只能在当前文件内引用, 类似 C++ private**==
5. 程序终止
    - return
    - ==exit(0)== -------\==stdlib.h==

* * *

## 递归

1. 条件
    - 大问题 ----子问题 -------\子问题求解方式与大问题一样
    - 子问题的解 ----------------\大问题的解
    - 不存在重复计算
    - 递归层次不是很深
2. How?
    - 边界条件
    - 递归公式

* * *

## 指针

1. 声明 ---------\**`int *p;`**
    - int 为指针的基础类型
        - 表明指向的对象占几个 Bytes
        - 如何解释指向的内存空间

2. 操作
    - 解引用 ==*==
        - `int i = 5; int *p = &i;`
        - i ------------直接访问, 读取内存一次
        - \*p ----------间接访问, 读取内存两次 ------\*p 相当于 i 的别名
    - 赋值 =
        - ==野指针==
            - `int * p;`----------------------\指针未初始化
            - **`int * p = 0xFFABC;`**---------\指向未知区域 ----->  ==~~将整数值直接赋值给变量~~==
            - 野指针解引用 ---------\==未定义行为==
        - ==空指针== --------------------\指针字面值
            - ==stdlib.h== ----------------\NULL
            - 不指向任何对象的指针
            - 解引用--------------------\==空指针异常==
    - 算数运算 --------\为指针的偏移量
        - 指针 \+ 整数
        - 指针 \- 整数
        - 指针 \- 指针
    - 比较运算
    - 取下标 \[ \]
    - \* / \+\+ / --
        - **`*p++`** ----\**`*(p++)`**
        - (*p)++
        - **`*++p`** ----\**`*(++p)`**
        - **`++*p`** ----\**`++(*p)`**

3. 指针读写
    - 读 -----\禁止!
    - 写 -----\%p

4. 应用
    - 指针作为参数传递
        - 通过 形参 改变 实参 的数值
        - 指针类型的参数 可以作为 ==返回值== 来使用
    - 指针作为返回值
        - ==不要返回指向 **当前**栈帧 区域的指针==

5. 数组名作为指针来用
    - 作为参数传递
    - 作为返回值
    - 给指针变量赋值

6. 指针与数组关系
    - 可以用指针处理数组
    - 数组名可以作为指向它的第一个元素的指针来用
    - 指针也支持取下标元素

7. 通用指针 -------------\`void*`
    - 可与任意类型的指针互相转换
    - C++ 中不支持通用指针
        - `static_cast<类型>(malloc( ))`
        - `(类型 *) malloc( )` ---------\C++ 强制类型转换

8. 二级指针 -------\想修改一个变量, 就传输它的地址
    - 想修改指针指向的对象 --------\一级指针

    - 想修改指针变量的值 ----------\二级指针

    - <img src="https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/20230723212817.png" style="zoom:50%;" />
         - 访问 val

        - obj ---------访问内存 1 次
        - *p1 ---------访问内存 2 次
        - **p2 --------访问内存 3 次

9. 一等公民
    - 作为参数传递
    - 作为返回值返回
    - 赋值给一个变量

10. ==**函数指针**==
    - 类型
        - `int (*)(const void*, const void*)`
        - 声明
        - `int (*名)(const void*, const void*)`
    - 函数指针别名
        - `typedef int (*func)(const void*, const void*)`
        - `func f1;`
        - `func f2;`
    - 值
        - `foo, &foo, NULL`
    - 应用
        - 支持函数式编程
        - 创建一些功能非常强大的函数
        - 解耦
    - 回调函数 / 钩子函数
        - 函数指针作为参数传递时, 这个指针指向的函数被称为 回调函数(callback), 也叫钩子函数
        - <img src="https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/20230721162951.png" alt="" width="240" height="310" class="jop-noMdConv">

* * *

## 字符串

1. 内存布局

    - C 无字符串类型, 是一种逻辑类型, 依赖字符数组存在
    - 字符串的长度 与 字符数组长度不同, 可能比数组长, 也可能短
    - ![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/20230717160520.png)

    - <img src="https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/20230717161007.png" alt="" width="402" height="125" class="jop-noMdConv">
2. 字面值

    - 分类

        - 双引号括起来的字符序列

        - 字符串内以 \ 结尾, 下一行从头延续

            - ```c
                 printf("Hello \
                 World!")
              ```

        - 多个字符串仅以 空白字符 分割

            - ```c
                 printf("Hello "
                        "World!");
              ```

    - 操作 -------\==const char * const==

3. 初始化

    - 字符数组
        - `char date[ ] = "June 14";`
        - `"June 14"` 为数组初始化式的简写形式; 位于栈帧中, 可以修改
    - 字符指针
        - `char *date = "June 14";`
        - `"June 14"` 为字符串字面量; 位于代码段中, 不可修改
4. 字符串的读写

    - 写
        - printf( ) + %m.ps
            - m 为所占位置的最少数量; 正数为右对齐, 负数为左对齐
            - p 为要显示的字符数量
        - ==puts==( )
            - puts 会在后面添加一个额外的换行符
    - 读
        - scanf( ) + %s
            - %s ----忽略前置空白字符, 依次写入字符, 遇到空白字符结束, 并在末尾添加 \\0
            - 缺点
                - 不会检查数组是否越界 ------\没有传递数组长度
                - 不能包含空白字符 -----------\(' ', '\\n', '\\t', '\\v', '\\f')
        - ==gets==( )
            - 读一行数据, 遇到 \\n 结束, 并把 \\n 替换为 \\0
            - 缺点
                - 不会检查数组是否越界 ------\没有传递数组长度
        - ==fgets==(str, 10, stdin)
            - 可以保证数组不越界
5. 库函数 -------\==**string.h**==

    - 字符串==长度==
        - `size_t strlen(const char *s)`
    - ==拼接==字符串-------->  concatenate
        - `strcat(char * s1, const char * s2)` **--------------\有可能越界**
        - `strncat(s1, s2, sizeof(s1) - strlen(s1)-1)` **----\n为能够拼接的最大字符数目**
    - ==复制==(覆盖)
        - `strcpy(char* s1, const char* s2)` **----------------\有可能越界**
        - `strncpy(s1, s2, sizeof(s1) - 1)` **-----------------\n为能够复制的最大字符数目**
    - ==比较==
        - `strcmp(const char * s1, const char * s2)`
            - s1 s2 ------1 (+)
            - s1 = s2 ------0
            - s1 &lt; s2 ------&gt; -1 (-)
6. **==命令行参数==**

    - ![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/20230723212645.png)

    - `int main(int argc, char * argv[ ])`
        - `argc` --------\命令行参数的个数
                                                                                                                   - `argv[ ]` ------\参数数组, 即字符指针数组
        - `argv[0]` ----------\程序名, 即可执行程序的路径
                                    - 操作系统以 ==字符串== 形式传递命令行参数, 即 argv 是一个 字符指针数组, 数组中每一个指针指示的对象(字符串)即为参数
        - 类型转换 --------\==**`sscanf(argv[1], "%d", &n)`**==  --------------\从 **argv\[0\]** 读取, 转换为 ==int==(%d), 存储到 变量==n== 中
                                - 作用

        - 编写通用程序 ---------------\`cp src dst`
        - 改变程序默认行为 --------\`ls -l`

* * *

## Idiom

1. **声明字符串**

    - ```c
         #define LEN 80
         char str[LEN+1];
      ```

2. **计算字符串长度**

    - ```c
         char * p = s;
         while (*s) 
             s++;
         int len = s - p;
      ```

3. **搜索字符串的末尾**

    - ```c
         while (*s)
             s++;
      ```

4. **复制字符串, 包括空字符**

    - ```c
         while (*s1++ = *s2++) ;
      ```

5. **清空本行字符串**

    - ```c
         while (getchar() != '\n') ;
      ```

* * *

## 结构体

1. 内存布局
    - 分配在连续的内存空间中, 但被划分成的空间大小不定
    - 按声明顺序依次存放每个成员
    - 有对齐要求, x86 填充为 4Bytes 的倍数
2. 定义 / 声明 结构体类型
    - `typedef struct 结构体标签 { } 别名;`
    - 结构体定义别名时可以省略标签 -------\匿名结构体
3. 创建对象(结构体)
    - `struct 结构体标签 变量;`
    - `别名 变量 = { ... };`
    - 结构体标签不能单独使用
4. 初始化 -------\未被初始化的成员会被赋值为 **0**
5. 操作
    - 获取成员
        - 结构体名称 -------\获取成员运算符
        - 结构体指针 -------\右箭头运算符
    - 赋值

* * *

## 枚举

1. 特点
    - 用于表示==离散==值
    - 特别适合表示==状态==
2. 声明
    - `typedef enum 枚举标签 {  } 别名;`
    - 枚举定义别名时可以省略标签
3. 创建枚举变量
    - `别名 变量 = ...;`

* * *

## 动态内存分配

1. 函数
    - `void * malloc(size_t size)`

        - memory allocate
        - 分配 size 个 Byte 的内存块, 不清零
    - `void * calloc(size_t nmemb, size_t size)`

        - clear allocate
        - 为数组分配空间, 数组有 nmemb 个元素, 每个元素大小为 size 字节
        - 长度为1, 即分配一个空间
        - **清零**

    - `void * realloc(void *ptr, size_t size)`

        - resize allocate
        - 调整先前分配的内存块大小
        - 申请失败, 旧内存块数据不变
        - 新内存块大于旧内存块, 超过的部分**不会初始化**
        - 第 1 个参数为 空指针 --------mallc( )
        - 第 2 个参数为 0 --------------free( )

        - ```c
             #include<stdlib.h                                                                      
             int * p = realloc(ptr, size);
             if (!p) {// 错误处理
                 exit(1);
             }
             ptr = p
          ```

    - free()

        - 只能 free ==堆==上的数据
        - 传递给 free( ) 的参数必须是由**内存分配函数**返回的指针, 且为首字节
        - 禁止 **double-free**
        - 悬空指针, 即野指针
    - 注:
        - `void *` 为通用指针, 可与任意类型的指针互相转换
        - C++ 中不支持通用指针
            - `static_cast<类型>(malloc( ))`
            - `(类型 *) malloc( )` ---------\C++ 强制类型转换
        - 分配失败返回 `NULL` (0x00000000)
            - `if (!p) { 错误处理 }`

* * *

## 头文件

1. 概述

    - 类似其他编程语言的接口

    - 模块与模块之间是通过接口链接

2. C头文件内容

    - 对外接口的声明 (函数声明)

    - 结构体定义

3. `#include`

    - &lt; &gt; ------------\系统头文件包含目录
    - " "  ------------当前目录 ----------\系统头文件包含目录

* * *
