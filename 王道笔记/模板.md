# 模板

## 优点

1. 减少代码书写
2. 解决 强类型语言 的严格性与灵活性 问题

## 函数模板

### 形式

```c++
// template <class T>
template <typename T>   // 模板参数列表, T 表示参数类型
T add (T x, T y) {
    return x + y;
}
```

### 特点

1. 早期 C++ 代码不支持 typename, 只能使用 class 关键字表明类型
2. <mark>编译</mark>时完成 **函数模板 ---------> 模板函数**(实例化), 即完成 T 的推导
3. 函数模板 与 模板函数(普通函数) 可以进行重载
4. 模板函数(普通函数) 先于 函数模板 执行
5. 模板 不能分成 头文件 与 实现文件 的形式  
    若非要分开, 必须在头文件中 include 实现文件, `include xxx.tcc`

### 实例化

1. 显式实例化 `add(x, y)`
2. 隐式实例化 `add<int>(x, y)`

### 模板的特化

1. 全特化  
    将所有的模板参数都以特殊形式展示出来

2. 偏特化  
    将部分的模板参数以特殊形式展示出来

```c++
template <class T1, typename T2> 
T1 add(T1 x, T2 y) {
    ...;
}

// 偏特化
template <class T1>
T1 add(T1 x, int y) {
    ...;
}

// 全特化
template <>
int add(int x, double y) {
    ...;
}
```

### 模板参数类型

1. 类型参数  
    可以<mark>推导</mark>为 int / double / long
2. 非类型参数  
    只能为整形, bool / char / short / int / size_t / long / void*

```c++
// T 为 类型参数
// kMin 为 非类型参数
template <typename T, short kMin> 
T multiply(T x, T y) {
    return x * y * kMin;
}

// 1. 显式实例化
multiply<int, 100>(xxx, xxx);

// 2. 模板参数设置默认值
template <typename T = int, short kMin = 10> 
T multiply(T x, T y) {
    return x * y * kMin;
}
```

## 类模板

