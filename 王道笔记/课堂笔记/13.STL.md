# STL  

(标准模板库, Standard Template Library)

## 容器

### 序列式容器

#### 初始化

|     | vector | deque | list |
| --- | :---: | :---: | :---: |
| 无参 | √ | √ | √ |
| count 个 value | √ | √ | √ |
| 迭代器范围 | √ | √ | √ |
| 拷贝/移动 构造 | √ | √ | √ |
| 初始化列表 (大括号) | √ | √ | √ |

#### 遍历

|     | vector | deque | list |
| --- | :---: | :---: | :---: |
| 下标 | √ | √ | <mark>×</mark> |
| 迭代器 | √ | √ | √ |
| 增强 for 循环 (依托 迭代器) | √ | √ | √ |

#### 基本操作

|     |     | vector | deque | list |
| --- | --- | :---: | :---: | :---: |
|     | push_front() | <mark>×</mark> | √ | √ |
|     | pop_front() | <mark>×</mark> | √ | √ |
|     |  |  |  |  |
| 就地插入, 避免拷贝 | emplace_back() | √ | √ | √ |
| 有可能拷贝 | push_back() | √ | √ | √ |
|     | pop_back() | √ | √ | √ |
|     |  |  |  |  |
|     | insert() | √ | √ | √ |
|     |  |  |  |  |
|     | erase() | √ | √ | √ |
|     |  |  |  |  |
|     | resize() | √ | √ | √ |
|     |  |  |  |  |
|     | swap() | √ | √ | √ |
|     |  |  |  |  |
|     | clear() | √ | √ | √ |
|     | capacity() | √ | <mark>×</mark> | <mark>×</mark> |
| 回收未使用空间 | shrink_to_fit() | √ | √ | <mark>×</mark> |
| 预留空间, 防止频繁扩容 | reserve() | √ | √ | √ |
| 获取第一个元素的地址 | data() | √ | √ | √ |
|     |  |  |  |  |
|     | reverse() |  |  | √ |
|     | sort() |  |  | √ |
| 移除连续重复元素 | unique() |  |  | √ |
| 合并两有序链表 | merge() |  |  | √ |
|     | splice() |  |  | √ |

1. 为何 vector 不支持在头部进行插入与删除呢?  

    vector中的元素是连续的, 如果在头部进行插入与删除的时间复杂度比较高 O(n)

2. `insert()`

    1. 插入方式

        1. 找一个位置插入 1 个元素

        2. 找一个位置插入 count 个 value

        3. 找一个位置插入 迭代器范围的元素

        4. 找一个位置插入 大括号范围的元素

    2. deque 插入存在 前半部分 与 后半部分 的概念

    3. vector 迭代器失效 (<mark>重要</mark>)

        1. 概念: 底层发生扩容现象, 而迭代器还指向老的空间, 使用 老的迭代器 去操作 新的空间  

        2. 解决方案: vector 每次插入前重新置位(获取) 迭代器

        3. insert 扩容策略

            size() = m, capacity() = n, 待插入的元素的个数 t
            1. t < n - m; 此时就不会扩容
            2. n - m < t < m; 会按照 2*m 进行扩容
            3. n - m < t, m < t; 会按照 m+t 进行扩容

            push_back 每次插入元素的个数都是固定的 1, 所以按照 两倍 进行扩容肯定容器是足够的;  
            但是 insert 进行插入元素的时候, 元素的个数是不一定的, 所以不能按照某个固定值的两倍进行扩容.

3. `erase()`: 删除元素

    删除元素后 迭代器 不要往后挪, 否则会漏掉某些元素

    ```c++
    for (auto it = x.begin(); it != it.end(); ) {
        if (*it == 7) {
            x.erase(it)
        } else {
            ++it;
        }
    }
    ```

#### vector

![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202309260956926.png)  

![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202309261024551.png)

结论: 在 vector 中随机访问的时候, 可以使用下标, 也可以使用 `at` 函数, 但是下标是没有范围检查的, 所以有可能出现越界的风险, 但是 `at` 函数是有范围检查的, 就没有越界的风险.

```c++
// 获取 vector 第一个元素地址
vector<int> numbet = {...};

&number[0];
&*number.begin();
int* pdata = number.data();
```

#### deque

![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202309261033477.png)  

![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202309261057206.png)

![](https://xiao060.oss-cn-hangzhou.aliyuncs.com/md/202309261104426.png)

特点:

1. 逻辑上连续, 物理上不连续

2. 片段之间是依靠中控器数组进行控制的

#### list

1. `sort()`

    1. 从小到大

        ```c++
        x.sort();
        x.sort(std::less<int>());
        ```

    2. 从大到小

        ```c++
        x.sort(std::greater<int>());
        ```

    3. <mark>自定义类型 排序方式</mark>

        1. 模板的特化

            ```c++
            namespace std{
            template <>
            struct less<Point> {
                bool operator()(const Point& lhs, const Point& rhs) const {
                    // 写出详细的比较流程
                    // ...;
                }
            }
            }
            ```

        2. 运算符重载

        3. 函数对象

            ```c++
            struct CompareList {
                bool operator()(const Point& lhs, const Point& rhs) const {
                    // 写出详细的比较流程
                    // ...;
                }
            }
            x.sort(CompareList);
            ```

2. `merge`

    merge的时候, 两个链表最好都按照从小到大进行排序, 否则合并到一起之后, 就不是有序的

3. `splice()`

    1. 将 number3 中的所有元素都移动到 number 中

        ```c++
        number.splice(it, number3);
        ```

    2. 将 number3 中的 nit 指向的元素移动到 number 中

        ```c++
        number.splice(it, number3, nit);
        ```

    3. 将 number3 中的 nit 到 nit2 范围的元素移动到 number 中

        ```c++
        // 可以在同一个链表中进行 splice 操作, but 如果移动范围交叉
        number.splice(it, number3, nit, nit2);
        ```

### 关联式容器  

#### 概述

1. 默认会将元素排序

2. 底层使用 <mark>红黑树</mark>

#### set

1. 不支持下标访问

2. 底层实现为 红黑树, 为了维护红黑树的稳定性, 不支持 修改操作

3. `insert()` 返回值为 `pair`

#### multiset

1. 相同点

    1. 不支持下标访问

    2. 底层实现为 红黑树, 为了维护红黑树的稳定性, 不支持 修改操作

    3. `count() / find() / erase()` 操纵相同

    4. 针对 自定义类型 的 Compare, 都支持 <mark>模板特化/运算符重载/函数对象</mark>

2. 不同点

    1. key 值不唯一

    2. `insert()` 插入 1 个元素, 返回值为 迭代器

    3. `equal_range`

    4. `lower_bound` 返回首个 >= 给定值的迭代器

    5. `upper_bound` 返回首个 > 给定值的迭代器

#### map

1. 特征

    1. 存放的是 key-value 类型,key 值是唯一的

    2. 默认会按照 key 值进行升序排列

    3. 底层实现也是使用红黑树

2. 初始化

    1. `pair<xxx>(xxx, xxx)`

    2. `{xxx, xxx}`

    3. `make_pair(xxx, xxx)`

3. <mark>下标访问</mark>  

    具备 查找 / 插入 / 修改 的功能, 但是没有 <mark>const</mark> 版本

#### multimap

1. 相同的

    1. 存放的是 key-value 类型,key 值是唯一的

    2. 默认会按照 key 值进行升序排列

    3. 底层实现也是使用红黑树

    4. 初始化方式 / count / erase 相同

2. 不同点

    1. `insert` 一对元素时, 返回值为迭代器, 而不是 `pair`

    2. <mark>不支持 下标</mark>, 因为 multimap 中 key 值可以重复, 若支持下标会导致 二义性

### 无序关联式容器  

#### 哈希冲突

##### 概述

1. 拉链法(链地址法)

2. 装填/装载因子 = 元素个数/表长 ∈ [0.5, 0.75]

3. 完美哈希: 数组

##### 自定义类型设置哈希函数

1. hash 模板特化

    ```c++
    template <>
    struct hash<Point> {
        size_t operator()(const Point& rhs) const {
            return ...;
        }
    }
    ```

2. hash 函数对象

    ```c++
    struct HashPoint {
        size_t operator()(const Point& rhs) const {
            return ...;
        }
    }
    ```

#### unordered_set

1. 无序

2. 存放 key 值, key 值唯一

3. 底层 哈希

4. count / find / erase / insert 与 set 相同

5. 不支持 下标

6. 针对自定义类型, 需要改写 `std::hash` (模板特化/函数对象) 及 `std::equal_to` (模板特化/重载/函数对象)

#### unordered_map

1. key 若为自定义类型, 需要改写 `std::hash` (模板特化/函数对象) 及 `std::equal_to` (模板特化/重载/函数对象)

#### 总结

|         | 首选 | 其次  | × |
|:-------:|:----:|:----:|:---:|
| 元素有序 | 关联式容器  | 序列式容器 + sort  | 无序关联容器 |
| 查找时间复杂度 | 无序关联容器 O(1) | 关联式容器 O(logN) | 序列式容器 O(N) |
| 下标访问    | vector / deque / map / unordered_map |

#### 优先级队列  

1. 原理  

    使用的是堆排序(默认是大顶堆), 当有新插入的元素的时候,会将堆顶与新插入的元素进行比较  

    如果堆顶比新插入的元素要小, 满足std::1ess,那么就会将新插入的元素作为新的堆顶  

    如果堆顶与新插入的元素进行比较, 堆顶比新插入的元素要大, 就不会满足std:1ess, 那么老的堆顶依旧是堆顶

2. 基本操作

    初始化可以使用无参构造函数,拷贝构造或者移动构造,迭代器范围的形式  

    遍历因为优先级队列没有迭代器, 所以不能使用迭代器的方式进行遍历; 也没有下标, 所以不能使用下标方式进行遍历; 如果要进行遍历, 可以使用 while 与 empty, 只要元素不空, 就可以持续遍历  

    **插入**操作使用的是 push 函数; **删除**操作使用的是 pop 函数, **获取**元素可以使用 top

## 迭代器

广义/泛型指针, 容器 与 算法之间的桥梁

### 类型

1. 随机访问迭代器  (++ / -- / += n / -= n)

    vector / deque

2. 双向迭代器  (++ / --)  

    list / 关联式迭代器

3. 前向迭代器 (++)  

    无序关联式迭代器

## 适配器

1. 容器的适配器: stack/queue/priority_queue(优先级队列)

2. 迭代器的适配器

3. 函数适配器

## 算法

lambda 表达式 (匿名函数)

```c++
// [] 捕获列表
// 返回类型可省略
// 匿名函数外的变量不能直接在 函数体中进行使用, 需要在捕获列表中捕获
// 若想 修改 捕获的值, 1. [&a]; 2. [a](...)mutable
[a](int& value)->void {
    ...;
}
```

## 函数对象(仿函数)

定制化操作, 例: 删除器

## 空间配置器

进行空间的申请与释放
